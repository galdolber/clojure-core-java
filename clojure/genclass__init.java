package clojure;

import clojure.lang.*;

public class genclass__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(java.lang.reflect.Modifier.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(java.lang.reflect.Constructor.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.asm.ClassWriter.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.asm.ClassVisitor.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.asm.Opcodes.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.asm.Type.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.asm.commons.Method.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.asm.commons.GeneratorAdapter.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.lang.IPersistentMap.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.lang.Compiler.class);
  ((Namespace)RT.CURRENT_NS.deref()).importClass(clojure.lang.Compiler.HostExpr.class);
  const__2.setMeta((IPersistentMap)const__11);
  const__2.bindRoot(new clojure.core_filter_methods());
  const__12.setMeta((IPersistentMap)const__15);
  const__12.bindRoot(new clojure.core_non_private_methods());
  const__16.setMeta((IPersistentMap)const__19);
  const__16.bindRoot(new clojure.core_protected_final_methods());
  const__20.setMeta((IPersistentMap)const__23);
  const__20.bindRoot(new clojure.core_ctor_sigs());
  const__24.setMeta((IPersistentMap)const__27);
  const__24.bindRoot(new clojure.core_escape_class_name());
  const__28.setMeta((IPersistentMap)const__31);
  const__28.bindRoot(new clojure.core_overload_name());
  const__32.setMeta((IPersistentMap)const__37);
  const__32.bindRoot(new clojure.core_find_field());
  const__38.setMeta((IPersistentMap)const__40);
  const__38.bindRoot(RT.mapUniqueKeys(const__41, ((java.lang.Class)java.lang.Long.TYPE), const__42, ((java.lang.Class)java.lang.Short.TYPE), const__43, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[F"))), const__44, ((java.lang.Class)java.lang.Void.TYPE), const__45, ((java.lang.Class)java.lang.Boolean.TYPE), const__46, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[D"))), const__47, ((java.lang.Class)java.lang.Float.TYPE), const__48, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[C"))), const__49, ((java.lang.Class)java.lang.Byte.TYPE), const__50, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[I"))), const__51, ((java.lang.Class)java.lang.Character.TYPE), const__52, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[B"))), const__53, ((java.lang.Class)java.lang.Integer.TYPE), const__54, ((java.lang.Class)java.lang.Double.TYPE), const__55, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[Z"))), const__56, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[J"))), const__57, ((java.lang.Class)java.lang.Class.forName((java.lang.String)((java.lang.String)"[S")))));
  const__58.setMeta((IPersistentMap)const__62);
  const__58.bindRoot(new clojure.core_the_class());
  const__63.setMeta((IPersistentMap)const__66);
  const__63.bindRoot(new clojure.core_valid_java_method_name());
  const__67.setMeta((IPersistentMap)const__70);
  const__67.bindRoot(new clojure.core_validate_generate_class_options());
  const__71.setMeta((IPersistentMap)const__74);
  const__71.bindRoot(new clojure.core_generate_class());
  const__75.setMeta((IPersistentMap)const__80);
  const__75.bindRoot(new clojure.core_gen_class());
  ((clojure.lang.Var)const__75).setMacro();
  const__81.setMeta((IPersistentMap)const__85);
  const__81.bindRoot(new clojure.core_asm_type());
  const__86.setMeta((IPersistentMap)const__89);
  const__86.bindRoot(new clojure.core_generate_interface());
  const__90.setMeta((IPersistentMap)const__93);
  const__90.bindRoot(new clojure.core_gen_interface());
  ((clojure.lang.Var)const__90).setMacro();
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Var const__2;
 private static clojure.lang.Keyword const__3;
 private static clojure.lang.Keyword const__4;
 private static java.lang.Integer const__5;
 private static clojure.lang.Keyword const__6;
 private static java.lang.Integer const__7;
 private static clojure.lang.Keyword const__8;
 private static clojure.lang.IPersistentList const__9;
 private static clojure.lang.Keyword const__10;
 private static clojure.lang.IPersistentMap const__11;
 private static clojure.lang.Var const__12;
 private static java.lang.Integer const__13;
 private static clojure.lang.IPersistentList const__14;
 private static clojure.lang.IPersistentMap const__15;
 private static clojure.lang.Var const__16;
 private static java.lang.Integer const__17;
 private static clojure.lang.IPersistentList const__18;
 private static clojure.lang.IPersistentMap const__19;
 private static clojure.lang.Var const__20;
 private static java.lang.Integer const__21;
 private static clojure.lang.IPersistentList const__22;
 private static clojure.lang.IPersistentMap const__23;
 private static clojure.lang.Var const__24;
 private static java.lang.Integer const__25;
 private static clojure.lang.IPersistentList const__26;
 private static clojure.lang.IPersistentMap const__27;
 private static clojure.lang.Var const__28;
 private static java.lang.Integer const__29;
 private static clojure.lang.IPersistentList const__30;
 private static clojure.lang.IPersistentMap const__31;
 private static clojure.lang.Var const__32;
 private static java.lang.Integer const__33;
 private static clojure.lang.IPersistentList const__34;
 private static clojure.lang.Keyword const__35;
 private static java.lang.Class const__36;
 private static clojure.lang.IPersistentMap const__37;
 private static clojure.lang.Var const__38;
 private static java.lang.Integer const__39;
 private static clojure.lang.IPersistentMap const__40;
 private static clojure.lang.Symbol const__41;
 private static clojure.lang.Symbol const__42;
 private static clojure.lang.Symbol const__43;
 private static clojure.lang.Symbol const__44;
 private static clojure.lang.Symbol const__45;
 private static clojure.lang.Symbol const__46;
 private static clojure.lang.Symbol const__47;
 private static clojure.lang.Symbol const__48;
 private static clojure.lang.Symbol const__49;
 private static clojure.lang.Symbol const__50;
 private static clojure.lang.Symbol const__51;
 private static clojure.lang.Symbol const__52;
 private static clojure.lang.Symbol const__53;
 private static clojure.lang.Symbol const__54;
 private static clojure.lang.Symbol const__55;
 private static clojure.lang.Symbol const__56;
 private static clojure.lang.Symbol const__57;
 private static clojure.lang.Var const__58;
 private static java.lang.Integer const__59;
 private static clojure.lang.IPersistentList const__60;
 private static java.lang.Class const__61;
 private static clojure.lang.IPersistentMap const__62;
 private static clojure.lang.Var const__63;
 private static java.lang.Integer const__64;
 private static clojure.lang.IPersistentList const__65;
 private static clojure.lang.IPersistentMap const__66;
 private static clojure.lang.Var const__67;
 private static java.lang.Integer const__68;
 private static clojure.lang.IPersistentList const__69;
 private static clojure.lang.IPersistentMap const__70;
 private static clojure.lang.Var const__71;
 private static java.lang.Integer const__72;
 private static clojure.lang.IPersistentList const__73;
 private static clojure.lang.IPersistentMap const__74;
 private static clojure.lang.Var const__75;
 private static java.lang.Integer const__76;
 private static clojure.lang.IPersistentList const__77;
 private static clojure.lang.Keyword const__78;
 private static clojure.lang.Keyword const__79;
 private static clojure.lang.IPersistentMap const__80;
 private static clojure.lang.Var const__81;
 private static java.lang.Integer const__82;
 private static clojure.lang.IPersistentList const__83;
 private static java.lang.Class const__84;
 private static clojure.lang.IPersistentMap const__85;
 private static clojure.lang.Var const__86;
 private static java.lang.Integer const__87;
 private static clojure.lang.IPersistentList const__88;
 private static clojure.lang.IPersistentMap const__89;
 private static clojure.lang.Var const__90;
 private static java.lang.Integer const__91;
 private static clojure.lang.IPersistentList const__92;
 private static clojure.lang.IPersistentMap const__93;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__2 = (clojure.lang.Var)RT.var("clojure.core", "filter-methods");
  const__3 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__4 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__5 = (java.lang.Integer)1;
  const__6 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__7 = (java.lang.Integer)19;
  const__8 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__9 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), Symbol.intern(null, "invalid-method?"))));
  const__10 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__11 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), Symbol.intern(null, "invalid-method?")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 19, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__12 = (clojure.lang.Var)RT.var("clojure.core", "non-private-methods");
  const__13 = (java.lang.Integer)42;
  const__14 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))))));
  const__15 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 42, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__16 = (clojure.lang.Var)RT.var("clojure.core", "protected-final-methods");
  const__17 = (java.lang.Integer)51;
  const__18 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))))));
  const__19 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 51, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__20 = (clojure.lang.Var)RT.var("clojure.core", "ctor-sigs");
  const__21 = (java.lang.Integer)59;
  const__22 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "super")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))))));
  const__23 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "super")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 59, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__24 = (clojure.lang.Var)RT.var("clojure.core", "escape-class-name");
  const__25 = (java.lang.Integer)64;
  const__26 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))))));
  const__27 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 64, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__28 = (clojure.lang.Var)RT.var("clojure.core", "overload-name");
  const__29 = (java.lang.Integer)68;
  const__30 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "mname"), Symbol.intern(null, "pclasses"))));
  const__31 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "mname"), Symbol.intern(null, "pclasses")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 68, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__32 = (clojure.lang.Var)RT.var("clojure.core", "find-field");
  const__33 = (java.lang.Integer)74;
  const__34 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), Symbol.intern(null, "f"))));
  const__35 = (clojure.lang.Keyword)Keyword.intern(null, "tag");
  const__36 = (java.lang.Class)java.lang.reflect.Field.class;
  const__37 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), Symbol.intern(null, "f")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 74, Keyword.intern(null, "file"), "clojure/genclass.clj", Keyword.intern(null, "tag"), java.lang.reflect.Field.class);
  const__38 = (clojure.lang.Var)RT.var("clojure.core", "prim->class");
  const__39 = (java.lang.Integer)85;
  const__40 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 85, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__41 = (clojure.lang.Symbol)Symbol.intern(null, "long");
  const__42 = (clojure.lang.Symbol)Symbol.intern(null, "short");
  const__43 = (clojure.lang.Symbol)Symbol.intern(null, "floats");
  const__44 = (clojure.lang.Symbol)Symbol.intern(null, "void");
  const__45 = (clojure.lang.Symbol)Symbol.intern(null, "boolean");
  const__46 = (clojure.lang.Symbol)Symbol.intern(null, "doubles");
  const__47 = (clojure.lang.Symbol)Symbol.intern(null, "float");
  const__48 = (clojure.lang.Symbol)Symbol.intern(null, "chars");
  const__49 = (clojure.lang.Symbol)Symbol.intern(null, "byte");
  const__50 = (clojure.lang.Symbol)Symbol.intern(null, "ints");
  const__51 = (clojure.lang.Symbol)Symbol.intern(null, "char");
  const__52 = (clojure.lang.Symbol)Symbol.intern(null, "bytes");
  const__53 = (clojure.lang.Symbol)Symbol.intern(null, "int");
  const__54 = (clojure.lang.Symbol)Symbol.intern(null, "double");
  const__55 = (clojure.lang.Symbol)Symbol.intern(null, "booleans");
  const__56 = (clojure.lang.Symbol)Symbol.intern(null, "longs");
  const__57 = (clojure.lang.Symbol)Symbol.intern(null, "shorts");
  const__58 = (clojure.lang.Var)RT.var("clojure.core", "the-class");
  const__59 = (java.lang.Integer)104;
  const__60 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x"))));
  const__61 = (java.lang.Class)java.lang.Class.class;
  const__62 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 104, Keyword.intern(null, "file"), "clojure/genclass.clj", Keyword.intern(null, "tag"), java.lang.Class.class);
  const__63 = (clojure.lang.Var)RT.var("clojure.core", "valid-java-method-name");
  const__64 = (java.lang.Integer)115;
  const__65 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String"))))));
  const__66 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 115, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__67 = (clojure.lang.Var)RT.var("clojure.core", "validate-generate-class-options");
  const__68 = (java.lang.Integer)119;
  const__69 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.map(Keyword.intern(null, "keys"), RT.vector(Symbol.intern(null, "methods"))))));
  const__70 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.map(Keyword.intern(null, "keys"), RT.vector(Symbol.intern(null, "methods")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 119, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__71 = (clojure.lang.Var)RT.var("clojure.core", "generate-class");
  const__72 = (java.lang.Integer)124;
  const__73 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "options-map"))));
  const__74 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "options-map")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 124, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__75 = (clojure.lang.Var)RT.var("clojure.core", "gen-class");
  const__76 = (java.lang.Integer)665;
  const__77 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "options"))));
  const__78 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__79 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__80 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "options")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.0", Keyword.intern(null, "doc"), "When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by\n  (str prefix mymethod) (default prefix: \"-\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state]\n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier.\n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  It's return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n\n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in\n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \"-\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be\n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.", Keyword.intern(null, "line"), 665, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__81 = (clojure.lang.Var)RT.var("clojure.core", "asm-type");
  const__82 = (java.lang.Integer)801;
  const__83 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "c"))));
  const__84 = (java.lang.Class)clojure.asm.Type.class;
  const__85 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "c")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Returns an asm Type object for c, which may be a primitive class\n  (such as Integer/TYPE), any other class (such as Double), or a\n  fully-qualified class name given as a string or symbol\n  (such as 'java.lang.String)", Keyword.intern(null, "line"), 801, Keyword.intern(null, "file"), "clojure/genclass.clj", Keyword.intern(null, "tag"), clojure.asm.Type.class);
  const__86 = (clojure.lang.Var)RT.var("clojure.core", "generate-interface");
  const__87 = (java.lang.Integer)816;
  const__88 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.map(Keyword.intern(null, "keys"), RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "extends"), Symbol.intern(null, "methods"))))));
  const__89 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.map(Keyword.intern(null, "keys"), RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "extends"), Symbol.intern(null, "methods")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 816, Keyword.intern(null, "file"), "clojure/genclass.clj");
  const__90 = (clojure.lang.Var)RT.var("clojure.core", "gen-interface");
  const__91 = (java.lang.Integer)865;
  const__92 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "options"))));
  const__93 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "options")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.0", Keyword.intern(null, "doc"), "When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.", Keyword.intern(null, "line"), 865, Keyword.intern(null, "file"), "clojure/genclass.clj");
 }
 static {
  __init0();
  clojure.lang.Compiler.pushNSandLoader(clojure.genclass__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
