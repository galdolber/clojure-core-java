package clojure.pprint;

import clojure.lang.*;

public class pprint_base__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  const__2.setDynamic(true);
  const__2.setMeta((IPersistentMap)const__11);
  const__2.bindRoot(Boolean.TRUE);
  ((IFn)new clojure.pprint_fn__7603()).invoke();
  const__12.setDynamic(true);
  const__12.setMeta((IPersistentMap)const__14);
  const__12.bindRoot(const__15);
  const__16.setDynamic(true);
  const__16.setMeta((IPersistentMap)const__18);
  const__16.bindRoot(const__19);
  const__20.setDynamic(true);
  const__20.setMeta((IPersistentMap)const__23);
  const__20.bindRoot(null);
  const__24.setDynamic(true);
  const__24.setMeta((IPersistentMap)const__26);
  const__24.bindRoot(null);
  const__27.setDynamic(true);
  const__27.setMeta((IPersistentMap)const__29);
  const__27.bindRoot(null);
  const__30.setDynamic(true);
  const__30.setMeta((IPersistentMap)const__32);
  const__30.bindRoot(null);
  const__33.setDynamic(true);
  const__33.setMeta((IPersistentMap)const__35);
  const__33.bindRoot(null);
  const__36.setDynamic(true);
  const__36.setMeta((IPersistentMap)const__38);
  const__36.bindRoot(const__39);
  const__40.setDynamic(true);
  const__40.setMeta((IPersistentMap)const__42);
  const__40.bindRoot(const__43);
  const__44.setDynamic(true);
  const__44.setMeta((IPersistentMap)const__46);
  const__44.bindRoot(null);
  const__47.setMeta((IPersistentMap)const__50);
  const__51.setMeta((IPersistentMap)const__53);
  const__51.bindRoot(const__54.get());
  const__55.setMeta((IPersistentMap)const__59);
  const__55.bindRoot(new clojure.pprint_pr_with_base());
  const__60.setMeta((IPersistentMap)const__62);
  const__60.bindRoot(const__87);
  const__88.setMeta((IPersistentMap)const__91);
  const__88.bindRoot(new clojure.pprint_binding_map());
  ((clojure.lang.Var)const__88).setMacro();
  const__92.setMeta((IPersistentMap)const__95);
  const__92.bindRoot(new clojure.pprint_table_ize());
  const__96.setMeta((IPersistentMap)const__99);
  const__96.bindRoot(new clojure.pprint_pretty_writer_QMARK_());
  const__100.setMeta((IPersistentMap)const__103);
  const__100.bindRoot(new clojure.pprint_make_pretty_writer());
  const__104.setMeta((IPersistentMap)const__107);
  const__104.bindRoot(new clojure.pprint_with_pretty_writer());
  ((clojure.lang.Var)const__104).setMacro();
  const__108.setMeta((IPersistentMap)const__111);
  const__108.bindRoot(new clojure.pprint_write_out());
  const__112.setMeta((IPersistentMap)const__115);
  const__112.bindRoot(new clojure.pprint_write());
  const__116.setMeta((IPersistentMap)const__119);
  const__116.bindRoot(new clojure.pprint_pprint());
  const__120.setMeta((IPersistentMap)const__123);
  const__120.bindRoot(new clojure.pprint_pp());
  ((clojure.lang.Var)const__120).setMacro();
  const__124.setMeta((IPersistentMap)const__127);
  const__124.bindRoot(new clojure.pprint_set_pprint_dispatch());
  const__128.setMeta((IPersistentMap)const__131);
  const__128.bindRoot(new clojure.pprint_with_pprint_dispatch());
  ((clojure.lang.Var)const__128).setMacro();
  const__132.setMeta((IPersistentMap)const__135);
  const__132.bindRoot(new clojure.pprint_parse_lb_options());
  const__136.setMeta((IPersistentMap)const__139);
  const__136.bindRoot(new clojure.pprint_check_enumerated_arg());
  const__140.setMeta((IPersistentMap)const__143);
  const__140.bindRoot(new clojure.pprint_level_exceeded());
  const__144.setMeta((IPersistentMap)const__147);
  const__144.bindRoot(new clojure.pprint_pprint_logical_block());
  ((clojure.lang.Var)const__144).setMacro();
  const__148.setMeta((IPersistentMap)const__151);
  const__148.bindRoot(new clojure.pprint_pprint_newline());
  const__152.setMeta((IPersistentMap)const__155);
  const__152.bindRoot(new clojure.pprint_pprint_indent());
  const__156.setMeta((IPersistentMap)const__159);
  const__156.bindRoot(new clojure.pprint_pprint_tab());
  const__160.setMeta((IPersistentMap)const__163);
  const__160.bindRoot(new clojure.pprint_pll_mod_body());
  const__164.setMeta((IPersistentMap)const__167);
  const__164.bindRoot(new clojure.pprint_print_length_loop());
  ((clojure.lang.Var)const__164).setMacro();
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Var const__2;
 private static clojure.lang.Keyword const__3;
 private static clojure.lang.Keyword const__4;
 private static java.lang.Integer const__5;
 private static clojure.lang.Keyword const__6;
 private static java.lang.Integer const__7;
 private static clojure.lang.Keyword const__8;
 private static clojure.lang.Keyword const__9;
 private static clojure.lang.Keyword const__10;
 private static clojure.lang.IPersistentMap const__11;
 private static clojure.lang.Var const__12;
 private static java.lang.Integer const__13;
 private static clojure.lang.IPersistentMap const__14;
 private static java.lang.Long const__15;
 private static clojure.lang.Var const__16;
 private static java.lang.Integer const__17;
 private static clojure.lang.IPersistentMap const__18;
 private static java.lang.Long const__19;
 private static clojure.lang.Var const__20;
 private static java.lang.Integer const__21;
 private static clojure.lang.Keyword const__22;
 private static clojure.lang.IPersistentMap const__23;
 private static clojure.lang.Var const__24;
 private static java.lang.Integer const__25;
 private static clojure.lang.IPersistentMap const__26;
 private static clojure.lang.Var const__27;
 private static java.lang.Integer const__28;
 private static clojure.lang.IPersistentMap const__29;
 private static clojure.lang.Var const__30;
 private static java.lang.Integer const__31;
 private static clojure.lang.IPersistentMap const__32;
 private static clojure.lang.Var const__33;
 private static java.lang.Integer const__34;
 private static clojure.lang.IPersistentMap const__35;
 private static clojure.lang.Var const__36;
 private static java.lang.Integer const__37;
 private static clojure.lang.IPersistentMap const__38;
 private static java.lang.Long const__39;
 private static clojure.lang.Var const__40;
 private static java.lang.Integer const__41;
 private static clojure.lang.IPersistentMap const__42;
 private static java.lang.Long const__43;
 private static clojure.lang.Var const__44;
 private static java.lang.Integer const__45;
 private static clojure.lang.IPersistentMap const__46;
 private static clojure.lang.Var const__47;
 private static java.lang.Integer const__48;
 private static clojure.lang.Keyword const__49;
 private static clojure.lang.IPersistentMap const__50;
 private static clojure.lang.Var const__51;
 private static java.lang.Integer const__52;
 private static clojure.lang.IPersistentMap const__53;
 private static clojure.lang.Var const__54;
 private static clojure.lang.Var const__55;
 private static java.lang.Integer const__56;
 private static clojure.lang.Keyword const__57;
 private static clojure.lang.IPersistentList const__58;
 private static clojure.lang.IPersistentMap const__59;
 private static clojure.lang.Var const__60;
 private static java.lang.Integer const__61;
 private static clojure.lang.IPersistentMap const__62;
 private static clojure.lang.Keyword const__63;
 private static clojure.lang.Symbol const__64;
 private static clojure.lang.Keyword const__65;
 private static clojure.lang.Symbol const__66;
 private static clojure.lang.Keyword const__67;
 private static clojure.lang.Symbol const__68;
 private static clojure.lang.Keyword const__69;
 private static clojure.lang.Symbol const__70;
 private static clojure.lang.Keyword const__71;
 private static clojure.lang.Symbol const__72;
 private static clojure.lang.Keyword const__73;
 private static clojure.lang.Symbol const__74;
 private static clojure.lang.Keyword const__75;
 private static clojure.lang.Symbol const__76;
 private static clojure.lang.Keyword const__77;
 private static clojure.lang.Symbol const__78;
 private static clojure.lang.Keyword const__79;
 private static clojure.lang.Symbol const__80;
 private static clojure.lang.Keyword const__81;
 private static clojure.lang.Symbol const__82;
 private static clojure.lang.Keyword const__83;
 private static clojure.lang.Symbol const__84;
 private static clojure.lang.Keyword const__85;
 private static clojure.lang.Symbol const__86;
 private static clojure.lang.IPersistentMap const__87;
 private static clojure.lang.Var const__88;
 private static java.lang.Integer const__89;
 private static clojure.lang.IPersistentList const__90;
 private static clojure.lang.IPersistentMap const__91;
 private static clojure.lang.Var const__92;
 private static java.lang.Integer const__93;
 private static clojure.lang.IPersistentList const__94;
 private static clojure.lang.IPersistentMap const__95;
 private static clojure.lang.Var const__96;
 private static java.lang.Integer const__97;
 private static clojure.lang.IPersistentList const__98;
 private static clojure.lang.IPersistentMap const__99;
 private static clojure.lang.Var const__100;
 private static java.lang.Integer const__101;
 private static clojure.lang.IPersistentList const__102;
 private static clojure.lang.IPersistentMap const__103;
 private static clojure.lang.Var const__104;
 private static java.lang.Integer const__105;
 private static clojure.lang.IPersistentList const__106;
 private static clojure.lang.IPersistentMap const__107;
 private static clojure.lang.Var const__108;
 private static java.lang.Integer const__109;
 private static clojure.lang.IPersistentList const__110;
 private static clojure.lang.IPersistentMap const__111;
 private static clojure.lang.Var const__112;
 private static java.lang.Integer const__113;
 private static clojure.lang.IPersistentList const__114;
 private static clojure.lang.IPersistentMap const__115;
 private static clojure.lang.Var const__116;
 private static java.lang.Integer const__117;
 private static clojure.lang.IPersistentList const__118;
 private static clojure.lang.IPersistentMap const__119;
 private static clojure.lang.Var const__120;
 private static java.lang.Integer const__121;
 private static clojure.lang.IPersistentList const__122;
 private static clojure.lang.IPersistentMap const__123;
 private static clojure.lang.Var const__124;
 private static java.lang.Integer const__125;
 private static clojure.lang.IPersistentList const__126;
 private static clojure.lang.IPersistentMap const__127;
 private static clojure.lang.Var const__128;
 private static java.lang.Integer const__129;
 private static clojure.lang.IPersistentList const__130;
 private static clojure.lang.IPersistentMap const__131;
 private static clojure.lang.Var const__132;
 private static java.lang.Integer const__133;
 private static clojure.lang.IPersistentList const__134;
 private static clojure.lang.IPersistentMap const__135;
 private static clojure.lang.Var const__136;
 private static java.lang.Integer const__137;
 private static clojure.lang.IPersistentList const__138;
 private static clojure.lang.IPersistentMap const__139;
 private static clojure.lang.Var const__140;
 private static java.lang.Integer const__141;
 private static clojure.lang.IPersistentList const__142;
 private static clojure.lang.IPersistentMap const__143;
 private static clojure.lang.Var const__144;
 private static java.lang.Integer const__145;
 private static clojure.lang.PersistentVector const__146;
 private static clojure.lang.IPersistentMap const__147;
 private static clojure.lang.Var const__148;
 private static java.lang.Integer const__149;
 private static clojure.lang.IPersistentList const__150;
 private static clojure.lang.IPersistentMap const__151;
 private static clojure.lang.Var const__152;
 private static java.lang.Integer const__153;
 private static clojure.lang.IPersistentList const__154;
 private static clojure.lang.IPersistentMap const__155;
 private static clojure.lang.Var const__156;
 private static java.lang.Integer const__157;
 private static clojure.lang.IPersistentList const__158;
 private static clojure.lang.IPersistentMap const__159;
 private static clojure.lang.Var const__160;
 private static java.lang.Integer const__161;
 private static clojure.lang.IPersistentList const__162;
 private static clojure.lang.IPersistentMap const__163;
 private static clojure.lang.Var const__164;
 private static java.lang.Integer const__165;
 private static clojure.lang.IPersistentList const__166;
 private static clojure.lang.IPersistentMap const__167;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.pprint");
  const__2 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-pretty*");
  const__3 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__4 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__5 = (java.lang.Integer)1;
  const__6 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__7 = (java.lang.Integer)30;
  const__8 = (clojure.lang.Keyword)Keyword.intern(null, "dynamic");
  const__9 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__10 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__11 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Bind to true if you want write to use pretty printing", Keyword.intern(null, "line"), 30, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__12 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-right-margin*");
  const__13 = (java.lang.Integer)40;
  const__14 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.", Keyword.intern(null, "line"), 40, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__15 = (java.lang.Long)72L;
  const__16 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-miser-width*");
  const__17 = (java.lang.Integer)47;
  const__18 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.", Keyword.intern(null, "line"), 47, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__19 = (java.lang.Long)40L;
  const__20 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-lines*");
  const__21 = (java.lang.Integer)55;
  const__22 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__23 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)", Keyword.intern(null, "line"), 55, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__24 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-circle*");
  const__25 = (java.lang.Integer)61;
  const__26 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Mark circular structures (N.B. This is not yet used)", Keyword.intern(null, "line"), 61, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__27 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-shared*");
  const__28 = (java.lang.Integer)67;
  const__29 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Mark repeated structures rather than repeat them (N.B. This is not yet used)", Keyword.intern(null, "line"), 67, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__30 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-suppress-namespaces*");
  const__31 = (java.lang.Integer)72;
  const__32 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions", Keyword.intern(null, "line"), 72, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__33 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-radix*");
  const__34 = (java.lang.Integer)80;
  const__35 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", Keyword.intern(null, "line"), 80, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__36 = (clojure.lang.Var)RT.var("clojure.pprint", "*print-base*");
  const__37 = (java.lang.Integer)87;
  const__38 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "The base to use for printing integers and rationals.", Keyword.intern(null, "line"), 87, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__39 = (java.lang.Long)10L;
  const__40 = (clojure.lang.Var)RT.var("clojure.pprint", "*current-level*");
  const__41 = (java.lang.Integer)99;
  const__42 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 99, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__43 = (java.lang.Long)0L;
  const__44 = (clojure.lang.Var)RT.var("clojure.pprint", "*current-length*");
  const__45 = (java.lang.Integer)101;
  const__46 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 101, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__47 = (clojure.lang.Var)RT.var("clojure.pprint", "format-simple-number");
  const__48 = (java.lang.Integer)109;
  const__49 = (clojure.lang.Keyword)Keyword.intern(null, "declared");
  const__50 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "declared"), Boolean.TRUE, Keyword.intern(null, "line"), 109, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__51 = (clojure.lang.Var)RT.var("clojure.pprint", "orig-pr");
  const__52 = (java.lang.Integer)111;
  const__53 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 111, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__54 = (clojure.lang.Var)RT.var("clojure.core", "pr");
  const__55 = (clojure.lang.Var)RT.var("clojure.pprint", "pr-with-base");
  const__56 = (java.lang.Integer)113;
  const__57 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__58 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x"))));
  const__59 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 113, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__60 = (clojure.lang.Var)RT.var("clojure.pprint", "write-option-table");
  const__61 = (java.lang.Integer)118;
  const__62 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 118, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__63 = (clojure.lang.Keyword)Keyword.intern(null, "lines");
  const__64 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-lines*");
  const__65 = (clojure.lang.Keyword)Keyword.intern(null, "right-margin");
  const__66 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-right-margin*");
  const__67 = (clojure.lang.Keyword)Keyword.intern(null, "suppress-namespaces");
  const__68 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-suppress-namespaces*");
  const__69 = (clojure.lang.Keyword)Keyword.intern(null, "dispatch");
  const__70 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-pprint-dispatch*");
  const__71 = (clojure.lang.Keyword)Keyword.intern(null, "length");
  const__72 = (clojure.lang.Symbol)Symbol.intern("clojure.core", "*print-length*");
  const__73 = (clojure.lang.Keyword)Keyword.intern(null, "base");
  const__74 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-base*");
  const__75 = (clojure.lang.Keyword)Keyword.intern(null, "circle");
  const__76 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-circle*");
  const__77 = (clojure.lang.Keyword)Keyword.intern(null, "readably");
  const__78 = (clojure.lang.Symbol)Symbol.intern("clojure.core", "*print-readably*");
  const__79 = (clojure.lang.Keyword)Keyword.intern(null, "radix");
  const__80 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-radix*");
  const__81 = (clojure.lang.Keyword)Keyword.intern(null, "level");
  const__82 = (clojure.lang.Symbol)Symbol.intern("clojure.core", "*print-level*");
  const__83 = (clojure.lang.Keyword)Keyword.intern(null, "pretty");
  const__84 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-pretty*");
  const__85 = (clojure.lang.Keyword)Keyword.intern(null, "miser-width");
  const__86 = (clojure.lang.Symbol)Symbol.intern("clojure.pprint", "*print-miser-width*");
  const__87 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "lines"), Symbol.intern("clojure.pprint", "*print-lines*"), Keyword.intern(null, "right-margin"), Symbol.intern("clojure.pprint", "*print-right-margin*"), Keyword.intern(null, "suppress-namespaces"), Symbol.intern("clojure.pprint", "*print-suppress-namespaces*"), Keyword.intern(null, "dispatch"), Symbol.intern("clojure.pprint", "*print-pprint-dispatch*"), Keyword.intern(null, "length"), Symbol.intern("clojure.core", "*print-length*"), Keyword.intern(null, "base"), Symbol.intern("clojure.pprint", "*print-base*"), Keyword.intern(null, "circle"), Symbol.intern("clojure.pprint", "*print-circle*"), Keyword.intern(null, "readably"), Symbol.intern("clojure.core", "*print-readably*"), Keyword.intern(null, "radix"), Symbol.intern("clojure.pprint", "*print-radix*"), Keyword.intern(null, "level"), Symbol.intern("clojure.core", "*print-level*"), Keyword.intern(null, "pretty"), Symbol.intern("clojure.pprint", "*print-pretty*"), Keyword.intern(null, "miser-width"), Symbol.intern("clojure.pprint", "*print-miser-width*"));
  const__88 = (clojure.lang.Var)RT.var("clojure.pprint", "binding-map");
  const__89 = (java.lang.Integer)137;
  const__90 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__91 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 137, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__92 = (clojure.lang.Var)RT.var("clojure.pprint", "table-ize");
  const__93 = (java.lang.Integer)146;
  const__94 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "t"), Symbol.intern(null, "m"))));
  const__95 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "t"), Symbol.intern(null, "m")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 146, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__96 = (clojure.lang.Var)RT.var("clojure.pprint", "pretty-writer?");
  const__97 = (java.lang.Integer)151;
  const__98 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x"))));
  const__99 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Return true iff x is a PrettyWriter", Keyword.intern(null, "line"), 151, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
 }
 static void __init1() {
  const__100 = (clojure.lang.Var)RT.var("clojure.pprint", "make-pretty-writer");
  const__101 = (java.lang.Integer)155;
  const__102 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "base-writer"), Symbol.intern(null, "right-margin"), Symbol.intern(null, "miser-width"))));
  const__103 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "base-writer"), Symbol.intern(null, "right-margin"), Symbol.intern(null, "miser-width")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width", Keyword.intern(null, "line"), 155, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__104 = (clojure.lang.Var)RT.var("clojure.pprint", "with-pretty-writer");
  const__105 = (java.lang.Integer)160;
  const__106 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "base-writer"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__107 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "base-writer"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 160, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__108 = (clojure.lang.Var)RT.var("clojure.pprint", "write-out");
  const__109 = (java.lang.Integer)171;
  const__110 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "object"))));
  const__111 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "object")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", Keyword.intern(null, "line"), 171, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__112 = (clojure.lang.Var)RT.var("clojure.pprint", "write");
  const__113 = (java.lang.Integer)197;
  const__114 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "object"), Symbol.intern(null, "&"), Symbol.intern(null, "kw-args"))));
  const__115 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "object"), Symbol.intern(null, "&"), Symbol.intern(null, "kw-args")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", Keyword.intern(null, "line"), 197, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__116 = (clojure.lang.Var)RT.var("clojure.pprint", "pprint");
  const__117 = (java.lang.Integer)241;
  const__118 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "object")), RT.vector(Symbol.intern(null, "object"), Symbol.intern(null, "writer"))));
  const__119 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "object")), RT.vector(Symbol.intern(null, "object"), Symbol.intern(null, "writer")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.", Keyword.intern(null, "line"), 241, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__120 = (clojure.lang.Var)RT.var("clojure.pprint", "pp");
  const__121 = (java.lang.Integer)254;
  const__122 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector()));
  const__123 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector())), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", Keyword.intern(null, "line"), 254, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__124 = (clojure.lang.Var)RT.var("clojure.pprint", "set-pprint-dispatch");
  const__125 = (java.lang.Integer)260;
  const__126 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "function"))));
  const__127 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "function")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.", Keyword.intern(null, "line"), 260, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__128 = (clojure.lang.Var)RT.var("clojure.pprint", "with-pprint-dispatch");
  const__129 = (java.lang.Integer)274;
  const__130 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "function"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__131 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "function"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Execute body with the pretty print dispatch function bound to function.", Keyword.intern(null, "line"), 274, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__132 = (clojure.lang.Var)RT.var("clojure.pprint", "parse-lb-options");
  const__133 = (java.lang.Integer)285;
  const__134 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opts"), Symbol.intern(null, "body"))));
  const__135 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opts"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 285, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__136 = (clojure.lang.Var)RT.var("clojure.pprint", "check-enumerated-arg");
  const__137 = (java.lang.Integer)292;
  const__138 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "arg"), Symbol.intern(null, "choices"))));
  const__139 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "arg"), Symbol.intern(null, "choices")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 292, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__140 = (clojure.lang.Var)RT.var("clojure.pprint", "level-exceeded");
  const__141 = (java.lang.Integer)299;
  const__142 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector()));
  const__143 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector())), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 299, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__144 = (clojure.lang.Var)RT.var("clojure.pprint", "pprint-logical-block");
  const__145 = (java.lang.Integer)302;
  const__146 = (clojure.lang.PersistentVector)RT.vector(RT.vector(Symbol.intern(null, "options*"), Symbol.intern(null, "body")));
  const__147 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), RT.vector(RT.vector(Symbol.intern(null, "options*"), Symbol.intern(null, "body"))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.", Keyword.intern(null, "line"), 302, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__148 = (clojure.lang.Var)RT.var("clojure.pprint", "pprint-newline");
  const__149 = (java.lang.Integer)329;
  const__150 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "kind"))));
  const__151 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "kind")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", Keyword.intern(null, "line"), 329, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__152 = (clojure.lang.Var)RT.var("clojure.pprint", "pprint-indent");
  const__153 = (java.lang.Integer)341;
  const__154 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "relative-to"), Symbol.intern(null, "n"))));
  const__155 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "relative-to"), Symbol.intern(null, "n")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", Keyword.intern(null, "line"), 341, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__156 = (clojure.lang.Var)RT.var("clojure.pprint", "pprint-tab");
  const__157 = (java.lang.Integer)356;
  const__158 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "kind"), Symbol.intern(null, "colnum"), Symbol.intern(null, "colinc"))));
  const__159 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "kind"), Symbol.intern(null, "colnum"), Symbol.intern(null, "colinc")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", Keyword.intern(null, "line"), 356, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__160 = (clojure.lang.Var)RT.var("clojure.pprint", "pll-mod-body");
  const__161 = (java.lang.Integer)380;
  const__162 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "var-sym"), Symbol.intern(null, "body"))));
  const__163 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "var-sym"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 380, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
  const__164 = (clojure.lang.Var)RT.var("clojure.pprint", "print-length-loop");
  const__165 = (java.lang.Integer)391;
  const__166 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__167 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "bindings"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.3", Keyword.intern(null, "doc"), "A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.", Keyword.intern(null, "line"), 391, Keyword.intern(null, "file"), "clojure/pprint/pprint_base.clj");
 }
 static {
  __init0();
  __init1();
  clojure.lang.Compiler.pushNSandLoader(clojure.pprint.pprint_base__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
