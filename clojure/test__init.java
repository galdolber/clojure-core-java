package clojure;

import clojure.lang.*;

public class test__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((IFn)new clojure.test_loading__4931__auto__()).invoke();
  if (((clojure.lang.Symbol)const__1).equals(((java.lang.Object)const__2))) {
  } else {
   clojure.lang.LockingTransaction.runInTransaction((java.util.concurrent.Callable)((java.util.concurrent.Callable)new clojure.test_fn__7078()));
  }
  ((IFn)const__3.getRawRoot()).invoke(const__4);
  ((IFn)new clojure.test_fn__7080()).invoke();
  const__5.setDynamic(true);
  const__5.setMeta((IPersistentMap)const__14);
  const__5.bindRoot(null);
  const__15.setDynamic(true);
  const__15.setMeta((IPersistentMap)const__17);
  const__15.bindRoot(null);
  const__18.setDynamic(true);
  const__18.setMeta((IPersistentMap)const__20);
  const__18.bindRoot(const__26);
  const__27.setDynamic(true);
  const__27.setMeta((IPersistentMap)const__29);
  const__27.bindRoot(((IFn)const__30.getRawRoot()).invoke());
  const__31.setDynamic(true);
  const__31.setMeta((IPersistentMap)const__33);
  const__31.bindRoot(((IFn)const__30.getRawRoot()).invoke());
  const__34.setDynamic(true);
  const__34.setMeta((IPersistentMap)const__36);
  const__34.bindRoot(const__37.get());
  const__38.setMeta((IPersistentMap)const__42);
  const__38.bindRoot(new clojure.test_with_test_out());
  ((clojure.lang.Var)const__38).setMacro();
  const__43.setMeta((IPersistentMap)const__47);
  const__43.bindRoot(new clojure.test_file_position());
  const__48.setMeta((IPersistentMap)const__51);
  const__48.bindRoot(new clojure.test_testing_vars_str());
  const__52.setMeta((IPersistentMap)const__55);
  const__52.bindRoot(new clojure.test_testing_contexts_str());
  const__56.setMeta((IPersistentMap)const__59);
  const__56.bindRoot(new clojure.test_inc_report_counter());
  ((IFn)new clojure.test_fn__7095()).invoke();
  const__60.setMeta((IPersistentMap)const__64);
  const__60.bindRoot(new clojure.test_file_and_line());
  const__65.setMeta((IPersistentMap)const__68);
  const__65.bindRoot(new clojure.test_do_report());
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__70), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7104()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__23), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7106()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__24), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7108()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__25), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7111()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__71), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7114()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__72), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7116()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__73), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7118()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__74), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7120()));
  ((clojure.lang.MultiFn)const__69.get()).addMethod(((java.lang.Object)const__75), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7122()));
  const__76.setMeta((IPersistentMap)const__79);
  const__76.bindRoot(new clojure.test_get_possibly_unbound_var());
  const__80.setMeta((IPersistentMap)const__83);
  const__80.bindRoot(new clojure.test_function_QMARK_());
  const__84.setMeta((IPersistentMap)const__87);
  const__84.bindRoot(new clojure.test_assert_predicate());
  const__88.setMeta((IPersistentMap)const__91);
  const__88.bindRoot(new clojure.test_assert_any());
  ((IFn)new clojure.test_fn__7134()).invoke();
  ((clojure.lang.MultiFn)const__92.getRawRoot()).addMethod(((java.lang.Object)const__93), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7140()));
  ((clojure.lang.MultiFn)const__92.getRawRoot()).addMethod(((java.lang.Object)const__70), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7142()));
  ((clojure.lang.MultiFn)const__92.getRawRoot()).addMethod(((java.lang.Object)const__94), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7148()));
  ((clojure.lang.MultiFn)const__92.getRawRoot()).addMethod(((java.lang.Object)const__95), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7151()));
  ((clojure.lang.MultiFn)const__92.getRawRoot()).addMethod(((java.lang.Object)const__96), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7155()));
  const__97.setMeta((IPersistentMap)const__100);
  const__97.bindRoot(new clojure.test_try_expr());
  ((clojure.lang.Var)const__97).setMacro();
  const__101.setMeta((IPersistentMap)const__104);
  const__101.bindRoot(new clojure.test_is());
  ((clojure.lang.Var)const__101).setMacro();
  const__105.setMeta((IPersistentMap)const__108);
  const__105.bindRoot(new clojure.test_are());
  ((clojure.lang.Var)const__105).setMacro();
  const__109.setMeta((IPersistentMap)const__112);
  const__109.bindRoot(new clojure.test_testing());
  ((clojure.lang.Var)const__109).setMacro();
  const__113.setMeta((IPersistentMap)const__116);
  const__113.bindRoot(new clojure.test_with_test());
  ((clojure.lang.Var)const__113).setMacro();
  const__117.setMeta((IPersistentMap)const__120);
  const__117.bindRoot(new clojure.test_deftest());
  ((clojure.lang.Var)const__117).setMacro();
  const__121.setMeta((IPersistentMap)const__124);
  const__121.bindRoot(new clojure.test_deftest_());
  ((clojure.lang.Var)const__121).setMacro();
  const__125.setMeta((IPersistentMap)const__128);
  const__125.bindRoot(new clojure.test_set_test());
  ((clojure.lang.Var)const__125).setMacro();
  const__129.setMeta((IPersistentMap)const__132);
  const__129.bindRoot(new clojure.test_add_ns_meta());
  ((IFn)new clojure.test_fn__7171()).invoke();
  ((clojure.lang.MultiFn)const__133.getRawRoot()).addMethod(((java.lang.Object)const__134), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7177()));
  ((clojure.lang.MultiFn)const__133.getRawRoot()).addMethod(((java.lang.Object)const__135), (clojure.lang.IFn)((clojure.lang.IFn)new clojure.test_fn__7179()));
  const__136.setMeta((IPersistentMap)const__139);
  const__136.bindRoot(new clojure.test_default_fixture());
  const__140.setMeta((IPersistentMap)const__143);
  const__140.bindRoot(new clojure.test_compose_fixtures());
  const__144.setMeta((IPersistentMap)const__147);
  const__144.bindRoot(new clojure.test_join_fixtures());
  const__148.setDynamic(true);
  const__148.setMeta((IPersistentMap)const__151);
  const__148.bindRoot(new clojure.test_test_var());
  const__152.setMeta((IPersistentMap)const__155);
  const__152.bindRoot(new clojure.test_test_all_vars());
  const__156.setMeta((IPersistentMap)const__159);
  const__156.bindRoot(new clojure.test_test_ns());
  const__160.setMeta((IPersistentMap)const__163);
  const__160.bindRoot(new clojure.test_run_tests());
  const__164.setMeta((IPersistentMap)const__167);
  const__164.bindRoot(new clojure.test_run_all_tests());
  const__168.setMeta((IPersistentMap)const__171);
  const__168.bindRoot(new clojure.test_successful_QMARK_());
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Symbol const__2;
 private static clojure.lang.Var const__3;
 private static clojure.lang.PersistentVector const__4;
 private static clojure.lang.Var const__5;
 private static clojure.lang.Keyword const__6;
 private static clojure.lang.Keyword const__7;
 private static java.lang.Integer const__8;
 private static clojure.lang.Keyword const__9;
 private static java.lang.Integer const__10;
 private static clojure.lang.Keyword const__11;
 private static clojure.lang.Keyword const__12;
 private static clojure.lang.Keyword const__13;
 private static clojure.lang.IPersistentMap const__14;
 private static clojure.lang.Var const__15;
 private static java.lang.Integer const__16;
 private static clojure.lang.IPersistentMap const__17;
 private static clojure.lang.Var const__18;
 private static java.lang.Integer const__19;
 private static clojure.lang.IPersistentMap const__20;
 private static clojure.lang.Keyword const__21;
 private static java.lang.Long const__22;
 private static clojure.lang.Keyword const__23;
 private static clojure.lang.Keyword const__24;
 private static clojure.lang.Keyword const__25;
 private static clojure.lang.IPersistentMap const__26;
 private static clojure.lang.Var const__27;
 private static java.lang.Integer const__28;
 private static clojure.lang.IPersistentMap const__29;
 private static clojure.lang.Var const__30;
 private static clojure.lang.Var const__31;
 private static java.lang.Integer const__32;
 private static clojure.lang.IPersistentMap const__33;
 private static clojure.lang.Var const__34;
 private static java.lang.Integer const__35;
 private static clojure.lang.IPersistentMap const__36;
 private static clojure.lang.Var const__37;
 private static clojure.lang.Var const__38;
 private static java.lang.Integer const__39;
 private static clojure.lang.Keyword const__40;
 private static clojure.lang.IPersistentList const__41;
 private static clojure.lang.IPersistentMap const__42;
 private static clojure.lang.Var const__43;
 private static java.lang.Integer const__44;
 private static clojure.lang.IPersistentList const__45;
 private static clojure.lang.Keyword const__46;
 private static clojure.lang.IPersistentMap const__47;
 private static clojure.lang.Var const__48;
 private static java.lang.Integer const__49;
 private static clojure.lang.IPersistentList const__50;
 private static clojure.lang.IPersistentMap const__51;
 private static clojure.lang.Var const__52;
 private static java.lang.Integer const__53;
 private static clojure.lang.IPersistentList const__54;
 private static clojure.lang.IPersistentMap const__55;
 private static clojure.lang.Var const__56;
 private static java.lang.Integer const__57;
 private static clojure.lang.IPersistentList const__58;
 private static clojure.lang.IPersistentMap const__59;
 private static clojure.lang.Var const__60;
 private static java.lang.Integer const__61;
 private static clojure.lang.IPersistentList const__62;
 private static clojure.lang.Keyword const__63;
 private static clojure.lang.IPersistentMap const__64;
 private static clojure.lang.Var const__65;
 private static java.lang.Integer const__66;
 private static clojure.lang.IPersistentList const__67;
 private static clojure.lang.IPersistentMap const__68;
 private static clojure.lang.Var const__69;
 private static clojure.lang.Keyword const__70;
 private static clojure.lang.Keyword const__71;
 private static clojure.lang.Keyword const__72;
 private static clojure.lang.Keyword const__73;
 private static clojure.lang.Keyword const__74;
 private static clojure.lang.Keyword const__75;
 private static clojure.lang.Var const__76;
 private static java.lang.Integer const__77;
 private static clojure.lang.IPersistentList const__78;
 private static clojure.lang.IPersistentMap const__79;
 private static clojure.lang.Var const__80;
 private static java.lang.Integer const__81;
 private static clojure.lang.IPersistentList const__82;
 private static clojure.lang.IPersistentMap const__83;
 private static clojure.lang.Var const__84;
 private static java.lang.Integer const__85;
 private static clojure.lang.IPersistentList const__86;
 private static clojure.lang.IPersistentMap const__87;
 private static clojure.lang.Var const__88;
 private static java.lang.Integer const__89;
 private static clojure.lang.IPersistentList const__90;
 private static clojure.lang.IPersistentMap const__91;
 private static clojure.lang.Var const__92;
 private static clojure.lang.Keyword const__93;
 private static clojure.lang.Symbol const__94;
 private static clojure.lang.Symbol const__95;
 private static clojure.lang.Symbol const__96;
 private static clojure.lang.Var const__97;
 private static java.lang.Integer const__98;
 private static clojure.lang.IPersistentList const__99;
 private static clojure.lang.IPersistentMap const__100;
 private static clojure.lang.Var const__101;
 private static java.lang.Integer const__102;
 private static clojure.lang.IPersistentList const__103;
 private static clojure.lang.IPersistentMap const__104;
 private static clojure.lang.Var const__105;
 private static java.lang.Integer const__106;
 private static clojure.lang.IPersistentList const__107;
 private static clojure.lang.IPersistentMap const__108;
 private static clojure.lang.Var const__109;
 private static java.lang.Integer const__110;
 private static clojure.lang.IPersistentList const__111;
 private static clojure.lang.IPersistentMap const__112;
 private static clojure.lang.Var const__113;
 private static java.lang.Integer const__114;
 private static clojure.lang.IPersistentList const__115;
 private static clojure.lang.IPersistentMap const__116;
 private static clojure.lang.Var const__117;
 private static java.lang.Integer const__118;
 private static clojure.lang.IPersistentList const__119;
 private static clojure.lang.IPersistentMap const__120;
 private static clojure.lang.Var const__121;
 private static java.lang.Integer const__122;
 private static clojure.lang.IPersistentList const__123;
 private static clojure.lang.IPersistentMap const__124;
 private static clojure.lang.Var const__125;
 private static java.lang.Integer const__126;
 private static clojure.lang.IPersistentList const__127;
 private static clojure.lang.IPersistentMap const__128;
 private static clojure.lang.Var const__129;
 private static java.lang.Integer const__130;
 private static clojure.lang.IPersistentList const__131;
 private static clojure.lang.IPersistentMap const__132;
 private static clojure.lang.Var const__133;
 private static clojure.lang.Keyword const__134;
 private static clojure.lang.Keyword const__135;
 private static clojure.lang.Var const__136;
 private static java.lang.Integer const__137;
 private static clojure.lang.IPersistentList const__138;
 private static clojure.lang.IPersistentMap const__139;
 private static clojure.lang.Var const__140;
 private static java.lang.Integer const__141;
 private static clojure.lang.IPersistentList const__142;
 private static clojure.lang.IPersistentMap const__143;
 private static clojure.lang.Var const__144;
 private static java.lang.Integer const__145;
 private static clojure.lang.IPersistentList const__146;
 private static clojure.lang.IPersistentMap const__147;
 private static clojure.lang.Var const__148;
 private static java.lang.Integer const__149;
 private static clojure.lang.IPersistentList const__150;
 private static clojure.lang.IPersistentMap const__151;
 private static clojure.lang.Var const__152;
 private static java.lang.Integer const__153;
 private static clojure.lang.IPersistentList const__154;
 private static clojure.lang.IPersistentMap const__155;
 private static clojure.lang.Var const__156;
 private static java.lang.Integer const__157;
 private static clojure.lang.IPersistentList const__158;
 private static clojure.lang.IPersistentMap const__159;
 private static clojure.lang.Var const__160;
 private static java.lang.Integer const__161;
 private static clojure.lang.IPersistentList const__162;
 private static clojure.lang.IPersistentMap const__163;
 private static clojure.lang.Var const__164;
 private static java.lang.Integer const__165;
 private static clojure.lang.IPersistentList const__166;
 private static clojure.lang.IPersistentMap const__167;
 private static clojure.lang.Var const__168;
 private static java.lang.Integer const__169;
 private static clojure.lang.IPersistentList const__170;
 private static clojure.lang.IPersistentMap const__171;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "clojure.test")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "doc"), "A unit testing framework.\n\n    ASSERTIONS\n\n    The core of the library is the \"is\" macro, which lets you make\n    assertions of any arbitrary expression:\n\n    (is (= 4 (+ 2 2)))\n    (is (instance? Integer 256))\n    (is (.startsWith \"abcde\" \"ab\"))\n\n    You can type an \"is\" expression directly at the REPL, which will\n    print a message if it fails.\n\n    user> (is (= 5 (+ 2 2)))\n\n    FAIL in  (:1)\n    expected: (= 5 (+ 2 2))\n    actual: (not (= 5 4))\n    false\n\n    The \"expected:\" line shows you the original expression, and the\n    \"actual:\" shows you what actually happened.  In this case, it\n    shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n    \"false\" on the last line is the value returned from the\n    expression.  The \"is\" macro always returns the result of the\n    inner expression.\n\n    There are two special assertions for testing exceptions.  The\n    \"(is (thrown? c ...))\" form tests if an exception of class c is\n    thrown:\n\n    (is (thrown? ArithmeticException (/ 1 0)))\n\n    \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n    tests that the message on the exception matches the regular\n    expression re:\n\n    (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n    (/ 1 0)))\n\n    DOCUMENTING TESTS\n\n    \"is\" takes an optional second argument, a string describing the\n    assertion.  This message will be included in the error report.\n\n    (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n    In addition, you can document groups of assertions with the\n    \"testing\" macro, which takes a string followed by any number of\n    assertions.  The string will be included in failure reports.\n    Calls to \"testing\" may be nested, and all of the strings will be\n    joined together with spaces in the final report, in a style\n    similar to RSpec <http://rspec.info/>\n\n    (testing \"Arithmetic\"\n    (testing \"with positive integers\"\n    (is (= 4 (+ 2 2)))\n    (is (= 7 (+ 3 4))))\n    (testing \"with negative integers\"\n    (is (= -4 (+ -2 -2)))\n    (is (= -1 (+ 3 -4)))))\n\n    Note that, unlike RSpec, the \"testing\" macro may only be used\n    INSIDE a \"deftest\" or \"with-test\" form (see below).\n\n\n    DEFINING TESTS\n\n    There are two ways to define tests.  The \"with-test\" macro takes\n    a defn or def form as its first argument, followed by any number\n    of assertions.  The tests will be stored as metadata on the\n    definition.\n\n    (with-test\n    (defn my-function [x y]\n    (+ x y))\n    (is (= 4 (my-function 2 2)))\n    (is (= 7 (my-function 3 4))))\n\n    As of Clojure SVN rev. 1221, this does not work with defmacro.\n    See http://code.google.com/p/clojure/issues/detail?id=51\n\n    The other way lets you define tests separately from the rest of\n    your code, even in a different namespace:\n\n    (deftest addition\n    (is (= 4 (+ 2 2)))\n    (is (= 7 (+ 3 4))))\n\n    (deftest subtraction\n    (is (= 1 (- 4 3)))\n    (is (= 3 (- 7 4))))\n\n    This creates functions named \"addition\" and \"subtraction\", which\n    can be called like any other function.  Therefore, tests can be\n    grouped and composed, in a style similar to the test framework in\n    Peter Seibel's \"Practical Common Lisp\"\n    <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n    (deftest arithmetic\n    (addition)\n    (subtraction))\n\n    The names of the nested tests will be joined in a list, like\n    \"(arithmetic addition)\", in failure reports.  You can use nested\n    tests to set up a context shared by several tests.\n\n\n    RUNNING TESTS\n\n    Run tests with the function \"(run-tests namespaces...)\":\n\n    (run-tests 'your.namespace 'some.other.namespace)\n\n    If you don't specify any namespaces, the current namespace is\n    used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n    By default, these functions will search for all tests defined in\n    a namespace and run them in an undefined order.  However, if you\n    are composing tests, as in the \"arithmetic\" example above, you\n    probably do not want the \"addition\" and \"subtraction\" tests run\n    separately.  In that case, you must define a special function\n    named \"test-ns-hook\" that runs your tests in the correct order:\n\n    (defn test-ns-hook []\n    (arithmetic))\n\n    Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n    OMITTING TESTS FROM PRODUCTION CODE\n\n    You can bind the variable \"*load-tests*\" to false when loading or\n    compiling code in production.  This will prevent any tests from\n    being created by \"with-test\" or \"deftest\".\n\n\n    FIXTURES\n\n    Fixtures allow you to run code before and after tests, to set up\n    the context in which tests should be run.\n\n    A fixture is just a function that calls another function passed as\n    an argument.  It looks like this:\n\n    (defn my-fixture [f]\n    Perform setup, establish bindings, whatever.\n    (f)  Then call the function we were passed.\n    Tear-down / clean-up code here.\n    )\n\n    Fixtures are attached to namespaces in one of two ways.  \"each\"\n    fixtures are run repeatedly, once for each test function created\n    with \"deftest\" or \"with-test\".  \"each\" fixtures are useful for\n    establishing a consistent before/after state for each test, like\n    clearing out database tables.\n\n    \"each\" fixtures can be attached to the current namespace like this:\n    (use-fixtures :each fixture1 fixture2 ...)\n    The fixture1, fixture2 are just functions like the example above.\n    They can also be anonymous functions, like this:\n    (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n    The other kind of fixture, a \"once\" fixture, is only run once,\n    around ALL the tests in the namespace.  \"once\" fixtures are useful\n    for tasks that only need to be performed once, like establishing\n    database connections, or for time-consuming tasks.\n\n    Attach \"once\" fixtures to the current namespace like this:\n    (use-fixtures :once fixture1 fixture2 ...)\n\n    Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n    are using test-ns-hook, fixture functions will *never* be run.\n\n\n    SAVING TEST OUTPUT TO A FILE\n\n    All the test reporting functions write to the var *test-out*.  By\n    default, this is the same as *out*, but you can rebind it to any\n    PrintWriter.  For example, it could be a file opened with\n    clojure.java.io/writer.\n\n\n    EXTENDING TEST-IS (ADVANCED)\n\n    You can extend the behavior of the \"is\" macro by defining new\n    methods for the \"assert-expr\" multimethod.  These methods are\n    called during expansion of the \"is\" macro, so they should return\n    quoted forms to be evaluated.\n\n    You can plug in your own test-reporting framework by rebinding\n    the \"report\" function: (report event)\n\n    The 'event' argument is a map.  It will always have a :type key,\n    whose value will be a keyword signaling the type of event being\n    reported.  Standard events with :type value of :pass, :fail, and\n    :error are called when an assertion passes, fails, and throws an\n    exception, respectively.  In that case, the event will also have\n    the following keys:\n\n    :expected   The form that was expected to be true\n    :actual     A form representing what actually occurred\n    :message    The string message given as an argument to 'is'\n\n    The \"testing\" strings will be a list in \"*testing-contexts*\", and\n    the vars being tested will be a list in \"*testing-vars*\".\n\n    Your \"report\" function should wrap any printing calls in the\n    \"with-test-out\" macro, which rebinds *out* to the current value\n    of *test-out*.\n\n    For additional event types, see the examples in the code.\n    ", Keyword.intern(null, "author"), "Stuart Sierra, with contributions and suggestions by\n    Chas Emerick, Allen Rohner, and Stuart Halloway"));
  const__2 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__3 = (clojure.lang.Var)RT.var("clojure.core", "require");
  const__4 = (clojure.lang.PersistentVector)RT.vector(Symbol.intern(null, "clojure.template"), Keyword.intern(null, "as"), Symbol.intern(null, "temp"));
  const__5 = (clojure.lang.Var)RT.var("clojure.test", "*stack-trace-depth*");
  const__6 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__7 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__8 = (java.lang.Integer)1;
  const__9 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__10 = (java.lang.Integer)253;
  const__11 = (clojure.lang.Keyword)Keyword.intern(null, "dynamic");
  const__12 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__13 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__14 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "The maximum depth of stack traces to print when an Exception\n    is thrown during a test.  Defaults to nil, which means print the\n    complete stack trace.", Keyword.intern(null, "line"), 253, Keyword.intern(null, "file"), "clojure/test.clj");
  const__15 = (clojure.lang.Var)RT.var("clojure.test", "*report-counters*");
  const__16 = (java.lang.Integer)263;
  const__17 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 263, Keyword.intern(null, "file"), "clojure/test.clj");
  const__18 = (clojure.lang.Var)RT.var("clojure.test", "*initial-report-counters*");
  const__19 = (java.lang.Integer)265;
  const__20 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 265, Keyword.intern(null, "file"), "clojure/test.clj");
  const__21 = (clojure.lang.Keyword)Keyword.intern(null, "test");
  const__22 = (java.lang.Long)0L;
  const__23 = (clojure.lang.Keyword)Keyword.intern(null, "pass");
  const__24 = (clojure.lang.Keyword)Keyword.intern(null, "fail");
  const__25 = (clojure.lang.Keyword)Keyword.intern(null, "error");
  const__26 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "pass"), 0L, Keyword.intern(null, "test"), 0L, Keyword.intern(null, "error"), 0L, Keyword.intern(null, "fail"), 0L);
  const__27 = (clojure.lang.Var)RT.var("clojure.test", "*testing-vars*");
  const__28 = (java.lang.Integer)268;
  const__29 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 268, Keyword.intern(null, "file"), "clojure/test.clj");
  const__30 = (clojure.lang.Var)RT.var("clojure.core", "list");
  const__31 = (clojure.lang.Var)RT.var("clojure.test", "*testing-contexts*");
  const__32 = (java.lang.Integer)270;
  const__33 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 270, Keyword.intern(null, "file"), "clojure/test.clj");
  const__34 = (clojure.lang.Var)RT.var("clojure.test", "*test-out*");
  const__35 = (java.lang.Integer)272;
  const__36 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 272, Keyword.intern(null, "file"), "clojure/test.clj");
  const__37 = (clojure.lang.Var)RT.var("clojure.core", "*out*");
  const__38 = (clojure.lang.Var)RT.var("clojure.test", "with-test-out");
  const__39 = (java.lang.Integer)274;
  const__40 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__41 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__42 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Runs body with *out* bound to the value of *test-out*.", Keyword.intern(null, "line"), 274, Keyword.intern(null, "file"), "clojure/test.clj");
  const__43 = (clojure.lang.Var)RT.var("clojure.test", "file-position");
  const__44 = (java.lang.Integer)283;
  const__45 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "n"))));
  const__46 = (clojure.lang.Keyword)Keyword.intern(null, "deprecated");
  const__47 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "n")))), Keyword.intern(null, "deprecated"), "1.2", Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.", Keyword.intern(null, "line"), 283, Keyword.intern(null, "file"), "clojure/test.clj");
  const__48 = (clojure.lang.Var)RT.var("clojure.test", "testing-vars-str");
  const__49 = (java.lang.Integer)295;
  const__50 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "m"))));
  const__51 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "m")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", Keyword.intern(null, "line"), 295, Keyword.intern(null, "file"), "clojure/test.clj");
  const__52 = (clojure.lang.Var)RT.var("clojure.test", "testing-contexts-str");
  const__53 = (java.lang.Integer)308;
  const__54 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector()));
  const__55 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector())), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", Keyword.intern(null, "line"), 308, Keyword.intern(null, "file"), "clojure/test.clj");
  const__56 = (clojure.lang.Var)RT.var("clojure.test", "inc-report-counter");
  const__57 = (java.lang.Integer)315;
  const__58 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"))));
  const__59 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", Keyword.intern(null, "line"), 315, Keyword.intern(null, "file"), "clojure/test.clj");
  const__60 = (clojure.lang.Var)RT.var("clojure.test", "file-and-line");
  const__61 = (java.lang.Integer)337;
  const__62 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "exception")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Throwable"))), Symbol.intern(null, "depth"))));
  const__63 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__64 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "exception")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Throwable"))), Symbol.intern(null, "depth")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 337, Keyword.intern(null, "file"), "clojure/test.clj");
  const__65 = (clojure.lang.Var)RT.var("clojure.test", "do-report");
  const__66 = (java.lang.Integer)345;
  const__67 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "m"))));
  const__68 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "m")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Add file and line information to a test result and call report.\n  If you are writing a custom assert-expr method, call this function\n  to pass test results to report.", Keyword.intern(null, "line"), 345, Keyword.intern(null, "file"), "clojure/test.clj");
  const__69 = (clojure.lang.Var)RT.var("clojure.test", "report");
  const__70 = (clojure.lang.Keyword)Keyword.intern(null, "default");
  const__71 = (clojure.lang.Keyword)Keyword.intern(null, "summary");
  const__72 = (clojure.lang.Keyword)Keyword.intern(null, "begin-test-ns");
  const__73 = (clojure.lang.Keyword)Keyword.intern(null, "end-test-ns");
  const__74 = (clojure.lang.Keyword)Keyword.intern(null, "begin-test-var");
  const__75 = (clojure.lang.Keyword)Keyword.intern(null, "end-test-var");
  const__76 = (clojure.lang.Var)RT.var("clojure.test", "get-possibly-unbound-var");
  const__77 = (java.lang.Integer)405;
  const__78 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "v"))));
  const__79 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "v")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Like var-get but returns nil if the var is unbound.", Keyword.intern(null, "line"), 405, Keyword.intern(null, "file"), "clojure/test.clj");
  const__80 = (clojure.lang.Var)RT.var("clojure.test", "function?");
  const__81 = (java.lang.Integer)413;
  const__82 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x"))));
  const__83 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", Keyword.intern(null, "line"), 413, Keyword.intern(null, "file"), "clojure/test.clj");
  const__84 = (clojure.lang.Var)RT.var("clojure.test", "assert-predicate");
  const__85 = (java.lang.Integer)425;
  const__86 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "msg"), Symbol.intern(null, "form"))));
  const__87 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "msg"), Symbol.intern(null, "form")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", Keyword.intern(null, "line"), 425, Keyword.intern(null, "file"), "clojure/test.clj");
  const__88 = (clojure.lang.Var)RT.var("clojure.test", "assert-any");
  const__89 = (java.lang.Integer)444;
  const__90 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "msg"), Symbol.intern(null, "form"))));
  const__91 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "msg"), Symbol.intern(null, "form")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", Keyword.intern(null, "line"), 444, Keyword.intern(null, "file"), "clojure/test.clj");
  const__92 = (clojure.lang.Var)RT.var("clojure.test", "assert-expr");
  const__93 = (clojure.lang.Keyword)Keyword.intern(null, "always-fail");
  const__94 = (clojure.lang.Symbol)Symbol.intern(null, "instance?");
  const__95 = (clojure.lang.Symbol)Symbol.intern(null, "thrown?");
  const__96 = (clojure.lang.Symbol)Symbol.intern(null, "thrown-with-msg?");
  const__97 = (clojure.lang.Var)RT.var("clojure.test", "try-expr");
  const__98 = (java.lang.Integer)526;
  const__99 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "msg"), Symbol.intern(null, "form"))));
 }
 static void __init1() {
  const__100 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "msg"), Symbol.intern(null, "form")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", Keyword.intern(null, "line"), 526, Keyword.intern(null, "file"), "clojure/test.clj");
  const__101 = (clojure.lang.Var)RT.var("clojure.test", "is");
  const__102 = (java.lang.Integer)542;
  const__103 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "form")), RT.vector(Symbol.intern(null, "form"), Symbol.intern(null, "msg"))));
  const__104 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "form")), RT.vector(Symbol.intern(null, "form"), Symbol.intern(null, "msg")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n\n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", Keyword.intern(null, "line"), 542, Keyword.intern(null, "file"), "clojure/test.clj");
  const__105 = (clojure.lang.Var)RT.var("clojure.test", "are");
  const__106 = (java.lang.Integer)560;
  const__107 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "argv"), Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "args"))));
  const__108 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "argv"), Symbol.intern(null, "expr"), Symbol.intern(null, "&"), Symbol.intern(null, "args")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)\n  2 (+ 1 1)\n  4 (* 2 2))\n  Expands to:\n  (do (is (= 2 (+ 1 1)))\n  (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", Keyword.intern(null, "line"), 560, Keyword.intern(null, "file"), "clojure/test.clj");
  const__109 = (clojure.lang.Var)RT.var("clojure.test", "testing");
  const__110 = (java.lang.Integer)585;
  const__111 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "string"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__112 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "string"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", Keyword.intern(null, "line"), 585, Keyword.intern(null, "file"), "clojure/test.clj");
  const__113 = (clojure.lang.Var)RT.var("clojure.test", "with-test");
  const__114 = (java.lang.Integer)597;
  const__115 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "definition"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__116 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "definition"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.", Keyword.intern(null, "line"), 597, Keyword.intern(null, "file"), "clojure/test.clj");
  const__117 = (clojure.lang.Var)RT.var("clojure.test", "deftest");
  const__118 = (java.lang.Integer)610;
  const__119 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__120 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.", Keyword.intern(null, "line"), 610, Keyword.intern(null, "file"), "clojure/test.clj");
  const__121 = (clojure.lang.Var)RT.var("clojure.test", "deftest-");
  const__122 = (java.lang.Integer)627;
  const__123 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__124 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Like deftest but creates a private var.", Keyword.intern(null, "line"), 627, Keyword.intern(null, "file"), "clojure/test.clj");
  const__125 = (clojure.lang.Var)RT.var("clojure.test", "set-test");
  const__126 = (java.lang.Integer)636;
  const__127 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__128 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.", Keyword.intern(null, "line"), 636, Keyword.intern(null, "file"), "clojure/test.clj");
  const__129 = (clojure.lang.Var)RT.var("clojure.test", "add-ns-meta");
  const__130 = (java.lang.Integer)649;
  const__131 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "key"), Symbol.intern(null, "coll"))));
  const__132 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "key"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Adds elements in coll to the current namespace metadata as the\n  value of key.", Keyword.intern(null, "line"), 649, Keyword.intern(null, "file"), "clojure/test.clj");
  const__133 = (clojure.lang.Var)RT.var("clojure.test", "use-fixtures");
  const__134 = (clojure.lang.Keyword)Keyword.intern(null, "each");
  const__135 = (clojure.lang.Keyword)Keyword.intern(null, "once");
  const__136 = (clojure.lang.Var)RT.var("clojure.test", "default-fixture");
  const__137 = (java.lang.Integer)669;
  const__138 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f"))));
  const__139 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "The default, empty, fixture function.  Just calls its argument.", Keyword.intern(null, "line"), 669, Keyword.intern(null, "file"), "clojure/test.clj");
  const__140 = (clojure.lang.Var)RT.var("clojure.test", "compose-fixtures");
  const__141 = (java.lang.Integer)675;
  const__142 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f1"), Symbol.intern(null, "f2"))));
  const__143 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f1"), Symbol.intern(null, "f2")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.", Keyword.intern(null, "line"), 675, Keyword.intern(null, "file"), "clojure/test.clj");
  const__144 = (clojure.lang.Var)RT.var("clojure.test", "join-fixtures");
  const__145 = (java.lang.Integer)682;
  const__146 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "fixtures"))));
  const__147 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "fixtures")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.", Keyword.intern(null, "line"), 682, Keyword.intern(null, "file"), "clojure/test.clj");
  const__148 = (clojure.lang.Var)RT.var("clojure.test", "test-var");
  const__149 = (java.lang.Integer)694;
  const__150 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "v"))));
  const__151 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "v")))), Keyword.intern(null, "dynamic"), Boolean.TRUE, Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).", Keyword.intern(null, "line"), 694, Keyword.intern(null, "file"), "clojure/test.clj");
  const__152 = (clojure.lang.Var)RT.var("clojure.test", "test-all-vars");
  const__153 = (java.lang.Integer)709;
  const__154 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "ns"))));
  const__155 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "ns")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Calls test-var on every var interned in the namespace, with fixtures.", Keyword.intern(null, "line"), 709, Keyword.intern(null, "file"), "clojure/test.clj");
  const__156 = (clojure.lang.Var)RT.var("clojure.test", "test-ns");
  const__157 = (java.lang.Integer)721;
  const__158 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "ns"))));
  const__159 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "ns")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.", Keyword.intern(null, "line"), 721, Keyword.intern(null, "file"), "clojure/test.clj");
  const__160 = (clojure.lang.Var)RT.var("clojure.test", "run-tests");
  const__161 = (java.lang.Integer)746;
  const__162 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "namespaces"))));
  const__163 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "namespaces")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.", Keyword.intern(null, "line"), 746, Keyword.intern(null, "file"), "clojure/test.clj");
  const__164 = (clojure.lang.Var)RT.var("clojure.test", "run-all-tests");
  const__165 = (java.lang.Integer)758;
  const__166 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "re"))));
  const__167 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "re")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", Keyword.intern(null, "line"), 758, Keyword.intern(null, "file"), "clojure/test.clj");
  const__168 = (clojure.lang.Var)RT.var("clojure.test", "successful?");
  const__169 = (java.lang.Integer)767;
  const__170 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "summary"))));
  const__171 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "summary")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.1", Keyword.intern(null, "doc"), "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", Keyword.intern(null, "line"), 767, Keyword.intern(null, "file"), "clojure/test.clj");
 }
 static {
  __init0();
  __init1();
  clojure.lang.Compiler.pushNSandLoader(clojure.test__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
