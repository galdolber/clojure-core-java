package clojure.core;

import clojure.lang.*;

public class protocols__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((IFn)new clojure.core.protocols_loading__4931__auto__()).invoke();
  if (((clojure.lang.Symbol)const__1).equals(((java.lang.Object)const__2))) {
  } else {
   clojure.lang.LockingTransaction.runInTransaction((java.util.concurrent.Callable)((java.util.concurrent.Callable)new clojure.core.protocols_fn__6031()));
  }
  ((IFn)new clojure.core.protocols_fn__6035()).invoke();
  ((IFn)const__3.getRawRoot()).invoke(const__4, const__5.getRawRoot(), const__6, "Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.");
  ((IFn)const__7).invoke(const__4, const__8);
  ((IFn)const__9.getRawRoot()).invoke(const__4, const__10.getRawRoot(), ((IFn)const__5.getRawRoot()).invoke(const__15, const__16, const__17, const__18, const__4, const__19, const__21, const__22, RT.mapUniqueKeys(((IFn)const__23.getRawRoot()).invoke(const__24.get(), ((IFn)const__25.getRawRoot()).invoke(const__26, ((IFn)const__10.getRawRoot()).invoke(const__27, RT.mapUniqueKeys(const__28, const__4)))), new clojure.core.protocols_fn__6038())));
  ((IFn)const__29.getRawRoot()).invoke(const__4.getRawRoot());
  ((IFn)new clojure.core.protocols_fn__6061()).invoke();
  ((IFn)const__3.getRawRoot()).invoke(const__31, const__5.getRawRoot(), const__6, "Protocol for concrete seq types that can reduce themselves\n  faster than first/next recursion. Called by clojure.core/reduce.");
  ((IFn)const__7).invoke(const__31, const__32);
  ((IFn)const__9.getRawRoot()).invoke(const__31, const__10.getRawRoot(), ((IFn)const__5.getRawRoot()).invoke(const__35, const__16, const__36, const__18, const__31, const__19, const__38, const__22, RT.mapUniqueKeys(((IFn)const__23.getRawRoot()).invoke(const__24.get(), ((IFn)const__25.getRawRoot()).invoke(const__39, ((IFn)const__10.getRawRoot()).invoke(const__40, RT.mapUniqueKeys(const__28, const__31)))), new clojure.core.protocols_fn__6064())));
  ((IFn)const__29.getRawRoot()).invoke(const__31.getRawRoot());
  const__42.setMeta((IPersistentMap)const__51);
  const__42.bindRoot(new clojure.core.protocols_seq_reduce());
  ((IFn)const__52.getRawRoot()).invoke(const__53, const__4.getRawRoot(), RT.mapUniqueKeys(const__20, new clojure.core.protocols_fn__6081()));
  ((IFn)const__52.getRawRoot()).invoke(const__54, const__4.getRawRoot(), RT.mapUniqueKeys(const__20, new clojure.core.protocols_fn__6083()));
  ((IFn)const__52.getRawRoot()).invoke(const__55, const__4.getRawRoot(), RT.mapUniqueKeys(const__20, new clojure.core.protocols_fn__6085()));
  ((IFn)const__52.getRawRoot()).invoke(const__56, const__4.getRawRoot(), RT.mapUniqueKeys(const__20, new clojure.core.protocols_fn__6087()));
  ((IFn)const__52.getRawRoot()).invoke(const__57, const__4.getRawRoot(), RT.mapUniqueKeys(const__20, new clojure.core.protocols_fn__6089()));
  ((IFn)const__52.getRawRoot()).invoke(null, const__4.getRawRoot(), RT.mapUniqueKeys(const__20, new clojure.core.protocols_fn__6091()));
  ((IFn)const__52.getRawRoot()).invoke(const__57, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6093()));
  ((IFn)const__52.getRawRoot()).invoke(const__58, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6096()));
  ((IFn)const__52.getRawRoot()).invoke(const__59, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6098()));
  ((IFn)const__52.getRawRoot()).invoke(const__60, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6100()));
  ((IFn)const__52.getRawRoot()).invoke(null, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6103()));
  const__61.setMeta((IPersistentMap)const__63);
  const__61.bindRoot(const__64);
  const__65.setMeta((IPersistentMap)const__68);
  const__65.bindRoot(new clojure.core.protocols_emit_array_impls_STAR_());
  const__69.setMeta((IPersistentMap)const__72);
  const__69.bindRoot(new clojure.core.protocols_emit_array_impls());
  ((clojure.lang.Var)const__69).setMacro();
  ((IFn)const__52.getRawRoot()).invoke(const__73, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6109()));
  ((IFn)const__52.getRawRoot()).invoke(const__74, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6111()));
  ((IFn)const__52.getRawRoot()).invoke(const__75, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6113()));
  ((IFn)const__52.getRawRoot()).invoke(const__76, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6115()));
  ((IFn)const__52.getRawRoot()).invoke(const__77, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6117()));
  ((IFn)const__52.getRawRoot()).invoke(const__78, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6119()));
  ((IFn)const__52.getRawRoot()).invoke(const__79, const__31.getRawRoot(), RT.mapUniqueKeys(const__37, new clojure.core.protocols_fn__6121()));
  ((IFn)new clojure.core.protocols_fn__6125()).invoke();
  ((IFn)const__3.getRawRoot()).invoke(const__80, const__5.getRawRoot(), const__6, "Protocol for concrete associative types that can reduce themselves\n  via a function of key and val faster than first/next recursion over map\n  entries. Called by clojure.core/reduce-kv, and has same\n  semantics (just different arg order).");
  ((IFn)const__7).invoke(const__80, const__81);
  ((IFn)const__9.getRawRoot()).invoke(const__80, const__10.getRawRoot(), ((IFn)const__5.getRawRoot()).invoke(const__84, const__16, const__85, const__18, const__80, const__19, const__87, const__22, RT.mapUniqueKeys(((IFn)const__23.getRawRoot()).invoke(const__24.get(), ((IFn)const__25.getRawRoot()).invoke(const__88, ((IFn)const__10.getRawRoot()).invoke(const__89, RT.mapUniqueKeys(const__28, const__80)))), new clojure.core.protocols_fn__6128())));
  ((IFn)const__29.getRawRoot()).invoke(const__80.getRawRoot());
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Symbol const__2;
 private static clojure.lang.Var const__3;
 private static clojure.lang.Var const__4;
 private static clojure.lang.Var const__5;
 private static clojure.lang.Keyword const__6;
 private static clojure.lang.Var const__7;
 private static clojure.lang.IPersistentList const__8;
 private static clojure.lang.Var const__9;
 private static clojure.lang.Var const__10;
 private static clojure.lang.Keyword const__11;
 private static clojure.lang.Symbol const__12;
 private static clojure.lang.Keyword const__13;
 private static java.lang.Class const__14;
 private static clojure.lang.IPersistentMap const__15;
 private static clojure.lang.Keyword const__16;
 private static clojure.lang.IPersistentMap const__17;
 private static clojure.lang.Keyword const__18;
 private static clojure.lang.Keyword const__19;
 private static clojure.lang.Keyword const__20;
 private static clojure.lang.IPersistentMap const__21;
 private static clojure.lang.Keyword const__22;
 private static clojure.lang.Var const__23;
 private static clojure.lang.Var const__24;
 private static clojure.lang.Var const__25;
 private static clojure.lang.Symbol const__26;
 private static clojure.lang.IPersistentMap const__27;
 private static clojure.lang.Keyword const__28;
 private static clojure.lang.Var const__29;
 private static clojure.lang.Symbol const__30;
 private static clojure.lang.Var const__31;
 private static clojure.lang.IPersistentList const__32;
 private static clojure.lang.Symbol const__33;
 private static java.lang.Class const__34;
 private static clojure.lang.IPersistentMap const__35;
 private static clojure.lang.IPersistentMap const__36;
 private static clojure.lang.Keyword const__37;
 private static clojure.lang.IPersistentMap const__38;
 private static clojure.lang.Symbol const__39;
 private static clojure.lang.IPersistentMap const__40;
 private static clojure.lang.Symbol const__41;
 private static clojure.lang.Var const__42;
 private static clojure.lang.Keyword const__43;
 private static clojure.lang.Keyword const__44;
 private static java.lang.Integer const__45;
 private static clojure.lang.Keyword const__46;
 private static java.lang.Integer const__47;
 private static clojure.lang.Keyword const__48;
 private static clojure.lang.IPersistentList const__49;
 private static clojure.lang.Keyword const__50;
 private static clojure.lang.IPersistentMap const__51;
 private static clojure.lang.Var const__52;
 private static java.lang.Class const__53;
 private static java.lang.Class const__54;
 private static java.lang.Class const__55;
 private static java.lang.Class const__56;
 private static java.lang.Class const__57;
 private static java.lang.Class const__58;
 private static java.lang.Class const__59;
 private static java.lang.Class const__60;
 private static clojure.lang.Var const__61;
 private static java.lang.Integer const__62;
 private static clojure.lang.IPersistentMap const__63;
 private static clojure.lang.IPersistentList const__64;
 private static clojure.lang.Var const__65;
 private static java.lang.Integer const__66;
 private static clojure.lang.IPersistentList const__67;
 private static clojure.lang.IPersistentMap const__68;
 private static clojure.lang.Var const__69;
 private static java.lang.Integer const__70;
 private static clojure.lang.IPersistentList const__71;
 private static clojure.lang.IPersistentMap const__72;
 private static java.lang.Class const__73;
 private static java.lang.Class const__74;
 private static java.lang.Class const__75;
 private static java.lang.Class const__76;
 private static java.lang.Class const__77;
 private static java.lang.Class const__78;
 private static java.lang.Class const__79;
 private static clojure.lang.Var const__80;
 private static clojure.lang.IPersistentList const__81;
 private static clojure.lang.Symbol const__82;
 private static java.lang.Class const__83;
 private static clojure.lang.IPersistentMap const__84;
 private static clojure.lang.IPersistentMap const__85;
 private static clojure.lang.Keyword const__86;
 private static clojure.lang.IPersistentMap const__87;
 private static clojure.lang.Symbol const__88;
 private static clojure.lang.IPersistentMap const__89;
 private static clojure.lang.Symbol const__90;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core.protocols");
  const__2 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__3 = (clojure.lang.Var)RT.var("clojure.core", "alter-meta!");
  const__4 = (clojure.lang.Var)RT.var("clojure.core.protocols", "CollReduce");
  const__5 = (clojure.lang.Var)RT.var("clojure.core", "assoc");
  const__6 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__7 = (clojure.lang.Var)RT.var("clojure.core", "assert-same-protocol");
  const__8 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(((clojure.lang.IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "doc"), null))));
  const__9 = (clojure.lang.Var)RT.var("clojure.core", "alter-var-root");
  const__10 = (clojure.lang.Var)RT.var("clojure.core", "merge");
  const__11 = (clojure.lang.Keyword)Keyword.intern(null, "on");
  const__12 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core.protocols.CollReduce");
  const__13 = (clojure.lang.Keyword)Keyword.intern(null, "on-interface");
  const__14 = (java.lang.Class)clojure.core.protocols.CollReduce.class;
  const__15 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "on"), Symbol.intern(null, "clojure.core.protocols.CollReduce"), Keyword.intern(null, "doc"), "Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.", Keyword.intern(null, "on-interface"), clojure.core.protocols.CollReduce.class);
  const__16 = (clojure.lang.Keyword)Keyword.intern(null, "sigs");
  const__17 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "coll-reduce"), RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "doc"), null))));
  const__18 = (clojure.lang.Keyword)Keyword.intern(null, "var");
  const__19 = (clojure.lang.Keyword)Keyword.intern(null, "method-map");
  const__20 = (clojure.lang.Keyword)Keyword.intern(null, "coll-reduce");
  const__21 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "coll-reduce"), Keyword.intern(null, "coll-reduce"));
  const__22 = (clojure.lang.Keyword)Keyword.intern(null, "method-builders");
  const__23 = (clojure.lang.Var)RT.var("clojure.core", "intern");
  const__24 = (clojure.lang.Var)RT.var("clojure.core", "*ns*");
  const__25 = (clojure.lang.Var)RT.var("clojure.core", "with-meta");
  const__26 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "doc"), null));
  const__27 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "coll-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "doc"), null)));
  const__28 = (clojure.lang.Keyword)Keyword.intern(null, "protocol");
  const__29 = (clojure.lang.Var)RT.var("clojure.core", "-reset-methods");
  const__30 = (clojure.lang.Symbol)Symbol.intern(null, "CollReduce");
  const__31 = (clojure.lang.Var)RT.var("clojure.core.protocols", "InternalReduce");
  const__32 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(((clojure.lang.IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")))), Keyword.intern(null, "doc"), null))));
  const__33 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core.protocols.InternalReduce");
  const__34 = (java.lang.Class)clojure.core.protocols.InternalReduce.class;
  const__35 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "on"), Symbol.intern(null, "clojure.core.protocols.InternalReduce"), Keyword.intern(null, "doc"), "Protocol for concrete seq types that can reduce themselves\n  faster than first/next recursion. Called by clojure.core/reduce.", Keyword.intern(null, "on-interface"), clojure.core.protocols.InternalReduce.class);
  const__36 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "internal-reduce"), RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")))), Keyword.intern(null, "doc"), null))));
  const__37 = (clojure.lang.Keyword)Keyword.intern(null, "internal-reduce");
  const__38 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "internal-reduce"), Keyword.intern(null, "internal-reduce"));
  const__39 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")))), Keyword.intern(null, "doc"), null));
  const__40 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "internal-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "seq"), Symbol.intern(null, "f"), Symbol.intern(null, "start")))), Keyword.intern(null, "doc"), null)));
  const__41 = (clojure.lang.Symbol)Symbol.intern(null, "InternalReduce");
  const__42 = (clojure.lang.Var)RT.var("clojure.core.protocols", "seq-reduce");
  const__43 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__44 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__45 = (java.lang.Integer)1;
  const__46 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__47 = (java.lang.Integer)24;
  const__48 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__49 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val"))));
  const__50 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__51 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "f"), Symbol.intern(null, "val")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 24, Keyword.intern(null, "file"), "clojure/core/protocols.clj");
  const__52 = (clojure.lang.Var)RT.var("clojure.core", "extend");
  const__53 = (java.lang.Class)java.lang.Iterable.class;
  const__54 = (java.lang.Class)clojure.lang.PersistentVector.class;
  const__55 = (java.lang.Class)clojure.lang.LazySeq.class;
  const__56 = (java.lang.Class)clojure.lang.ASeq.class;
  const__57 = (java.lang.Class)java.lang.Object.class;
  const__58 = (java.lang.Class)clojure.lang.ArraySeq.class;
  const__59 = (java.lang.Class)clojure.lang.StringSeq.class;
  const__60 = (java.lang.Class)clojure.lang.IChunkedSeq.class;
  const__61 = (clojure.lang.Var)RT.var("clojure.core.protocols", "arr-impl");
  const__62 = (java.lang.Integer)150;
  const__63 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 150, Keyword.intern(null, "file"), "clojure/core/protocols.clj");
  const__64 = (clojure.lang.IPersistentList)((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "internal-reduce"), RT.vector(Symbol.intern(null, "a-seq"), Symbol.intern(null, "f"), Symbol.intern(null, "val")), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "let"), RT.vector(Symbol.intern(null, "arr"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, ".array"), Symbol.intern(null, "a-seq")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 153, Keyword.intern(null, "column"), 15))), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "loop"), RT.vector(Symbol.intern(null, "i"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, ".index"), Symbol.intern(null, "a-seq")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 154, Keyword.intern(null, "column"), 16)), Symbol.intern(null, "val"), Symbol.intern(null, "val")), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "if"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "<"), Symbol.intern(null, "i"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "alength"), Symbol.intern(null, "arr")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 156, Keyword.intern(null, "column"), 18))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 156, Keyword.intern(null, "column"), 13)), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "let"), RT.vector(Symbol.intern(null, "ret"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "f"), Symbol.intern(null, "val"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "aget"), Symbol.intern(null, "arr"), Symbol.intern(null, "i")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 157, Keyword.intern(null, "column"), 28))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 157, Keyword.intern(null, "column"), 21))), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "if"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "reduced?"), Symbol.intern(null, "ret")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 158, Keyword.intern(null, "column"), 17)), PersistentList.create(java.util.Arrays.asList(Symbol.intern("clojure.core", "deref"), Symbol.intern(null, "ret"))), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "recur"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "inc"), Symbol.intern(null, "i")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 160, Keyword.intern(null, "column"), 22)), Symbol.intern(null, "ret")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 160, Keyword.intern(null, "column"), 15))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 158, Keyword.intern(null, "column"), 13))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 157, Keyword.intern(null, "column"), 11)), Symbol.intern(null, "val")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 156, Keyword.intern(null, "column"), 9))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 154, Keyword.intern(null, "column"), 7))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 153, Keyword.intern(null, "column"), 5))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 151, Keyword.intern(null, "column"), 4));
  const__65 = (clojure.lang.Var)RT.var("clojure.core.protocols", "emit-array-impls*");
  const__66 = (java.lang.Integer)163;
  const__67 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "syms"))));
  const__68 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "syms")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 163, Keyword.intern(null, "file"), "clojure/core/protocols.clj");
  const__69 = (clojure.lang.Var)RT.var("clojure.core.protocols", "emit-array-impls");
  const__70 = (java.lang.Integer)173;
  const__71 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "syms"))));
  const__72 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "syms")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 173, Keyword.intern(null, "file"), "clojure/core/protocols.clj");
  const__73 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_boolean.class;
  const__74 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_char.class;
  const__75 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_byte.class;
  const__76 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_double.class;
  const__77 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_float.class;
  const__78 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_long.class;
  const__79 = (java.lang.Class)clojure.lang.ArraySeq.ArraySeq_int.class;
  const__80 = (clojure.lang.Var)RT.var("clojure.core.protocols", "IKVReduce");
  const__81 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(((clojure.lang.IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")))), Keyword.intern(null, "doc"), null))));
  const__82 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core.protocols.IKVReduce");
  const__83 = (java.lang.Class)clojure.core.protocols.IKVReduce.class;
  const__84 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "on"), Symbol.intern(null, "clojure.core.protocols.IKVReduce"), Keyword.intern(null, "doc"), "Protocol for concrete associative types that can reduce themselves\n  via a function of key and val faster than first/next recursion over map\n  entries. Called by clojure.core/reduce-kv, and has same\n  semantics (just different arg order).", Keyword.intern(null, "on-interface"), clojure.core.protocols.IKVReduce.class);
  const__85 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "kv-reduce"), RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")))), Keyword.intern(null, "doc"), null))));
  const__86 = (clojure.lang.Keyword)Keyword.intern(null, "kv-reduce");
  const__87 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "kv-reduce"), Keyword.intern(null, "kv-reduce"));
  const__88 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")))), Keyword.intern(null, "doc"), null));
  const__89 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "kv-reduce")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "amap"), Symbol.intern(null, "f"), Symbol.intern(null, "init")))), Keyword.intern(null, "doc"), null)));
  const__90 = (clojure.lang.Symbol)Symbol.intern(null, "IKVReduce");
 }
 static {
  __init0();
  clojure.lang.Compiler.pushNSandLoader(clojure.core.protocols__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
