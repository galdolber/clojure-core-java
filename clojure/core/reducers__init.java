package clojure.core;

import clojure.lang.*;

public class reducers__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((IFn)new clojure.core.reducers_loading__4931__auto__()).invoke();
  if (((clojure.lang.Symbol)const__1).equals(((java.lang.Object)const__2))) {
  } else {
   clojure.lang.LockingTransaction.runInTransaction((java.util.concurrent.Callable)((java.util.concurrent.Callable)new clojure.core.reducers_fn__6624()));
  }
  ((IFn)const__3.getRawRoot()).invoke(const__4, const__5);
  const__6.set(Boolean.TRUE);
  const__7.setMeta((IPersistentMap)const__17);
  const__7.bindRoot(new clojure.core.reducers_compile_if());
  ((clojure.lang.Var)const__7).setMacro();
  const__18.setMeta((IPersistentMap)const__21);
  const__18.bindRoot(new clojure.lang.Delay((clojure.lang.IFn)((clojure.lang.IFn)new clojure.core.reducers_fn__6631())));
  const__22.setMeta((IPersistentMap)const__25);
  const__22.bindRoot(new clojure.core.reducers_fjtask());
  const__26.setMeta((IPersistentMap)const__29);
  const__26.bindRoot(new clojure.core.reducers_fjinvoke());
  const__30.setMeta((IPersistentMap)const__33);
  const__30.bindRoot(new clojure.core.reducers_fjfork());
  const__34.setMeta((IPersistentMap)const__37);
  const__34.bindRoot(new clojure.core.reducers_fjjoin());
  const__38.setMeta((IPersistentMap)const__41);
  const__38.bindRoot(new clojure.core.reducers_reduce());
  ((IFn)new clojure.core.reducers_fn__6640()).invoke();
  ((IFn)const__42.getRawRoot()).invoke(const__43, const__44.getRawRoot(), const__15, null);
  ((IFn)const__45).invoke(const__43, const__46);
  ((IFn)const__47.getRawRoot()).invoke(const__43, const__48.getRawRoot(), ((IFn)const__44.getRawRoot()).invoke(const__53, const__54, const__55, const__56, const__43, const__57, const__59, const__60, RT.mapUniqueKeys(((IFn)const__61.getRawRoot()).invoke(const__62.get(), ((IFn)const__63.getRawRoot()).invoke(const__64, ((IFn)const__48.getRawRoot()).invoke(const__65, RT.mapUniqueKeys(const__66, const__43)))), new clojure.core.reducers_fn__6643())));
  ((IFn)const__67.getRawRoot()).invoke(const__43.getRawRoot());
  const__69.setMeta((IPersistentMap)const__73);
  const__69.bindRoot(new clojure.core.reducers_fold());
  const__74.setMeta((IPersistentMap)const__77);
  const__74.bindRoot(new clojure.core.reducers_reducer());
  const__78.setMeta((IPersistentMap)const__81);
  const__78.bindRoot(new clojure.core.reducers_folder());
  const__82.setMeta((IPersistentMap)const__85);
  const__82.bindRoot(new clojure.core.reducers_do_curried());
  const__86.setMeta((IPersistentMap)const__89);
  const__86.bindRoot(new clojure.core.reducers_defcurried());
  ((clojure.lang.Var)const__86).setMacro();
  const__90.setMeta((IPersistentMap)const__93);
  const__90.bindRoot(new clojure.core.reducers_do_rfn());
  const__94.setMeta((IPersistentMap)const__97);
  const__94.bindRoot(new clojure.core.reducers_rfn());
  ((clojure.lang.Var)const__94).setMacro();
  const__98.setMeta((IPersistentMap)const__101);
  const__98.bindRoot(new clojure.core.reducers_map());
  const__102.setMeta((IPersistentMap)const__105);
  const__102.bindRoot(new clojure.core.reducers_mapcat());
  const__106.setMeta((IPersistentMap)const__109);
  const__106.bindRoot(new clojure.core.reducers_filter());
  const__110.setMeta((IPersistentMap)const__113);
  const__110.bindRoot(new clojure.core.reducers_remove());
  const__114.setMeta((IPersistentMap)const__117);
  const__114.bindRoot(new clojure.core.reducers_flatten());
  const__118.setMeta((IPersistentMap)const__121);
  const__118.bindRoot(new clojure.core.reducers_take_while());
  const__122.setMeta((IPersistentMap)const__125);
  const__122.bindRoot(new clojure.core.reducers_take());
  const__126.setMeta((IPersistentMap)const__129);
  const__126.bindRoot(new clojure.core.reducers_drop());
  ((IFn)new clojure.core.reducers_fn__6731()).invoke();
  const__130.setMeta((IPersistentMap)const__133);
  const__130.bindRoot(new clojure.core.reducers_cat());
  const__134.setMeta((IPersistentMap)const__137);
  const__134.bindRoot(new clojure.core.reducers_append_BANG_());
  const__138.setMeta((IPersistentMap)const__141);
  const__138.bindRoot(new clojure.core.reducers_foldcat());
  const__142.setMeta((IPersistentMap)const__145);
  const__142.bindRoot(new clojure.core.reducers_monoid());
  const__146.setMeta((IPersistentMap)const__149);
  const__146.bindRoot(new clojure.core.reducers_foldvec());
  ((IFn)const__150.getRawRoot()).invoke(const__151, const__43.getRawRoot(), RT.mapUniqueKeys(const__58, new clojure.core.reducers_fn__6756()));
  ((IFn)const__150.getRawRoot()).invoke(const__152, const__43.getRawRoot(), RT.mapUniqueKeys(const__58, new clojure.core.reducers_fn__6758()));
  ((IFn)const__150.getRawRoot()).invoke(const__153, const__43.getRawRoot(), RT.mapUniqueKeys(const__58, new clojure.core.reducers_fn__6760()));
  ((IFn)const__150.getRawRoot()).invoke(null, const__43.getRawRoot(), RT.mapUniqueKeys(const__58, new clojure.core.reducers_fn__6762()));
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Symbol const__2;
 private static clojure.lang.Var const__3;
 private static clojure.lang.Symbol const__4;
 private static clojure.lang.Symbol const__5;
 private static clojure.lang.Var const__6;
 private static clojure.lang.Var const__7;
 private static clojure.lang.Keyword const__8;
 private static clojure.lang.Keyword const__9;
 private static java.lang.Integer const__10;
 private static clojure.lang.Keyword const__11;
 private static java.lang.Integer const__12;
 private static clojure.lang.Keyword const__13;
 private static clojure.lang.IPersistentList const__14;
 private static clojure.lang.Keyword const__15;
 private static clojure.lang.Keyword const__16;
 private static clojure.lang.IPersistentMap const__17;
 private static clojure.lang.Var const__18;
 private static java.lang.Integer const__19;
 private static java.lang.Integer const__20;
 private static clojure.lang.IPersistentMap const__21;
 private static clojure.lang.Var const__22;
 private static java.lang.Integer const__23;
 private static clojure.lang.IPersistentList const__24;
 private static clojure.lang.IPersistentMap const__25;
 private static clojure.lang.Var const__26;
 private static java.lang.Integer const__27;
 private static clojure.lang.IPersistentList const__28;
 private static clojure.lang.IPersistentMap const__29;
 private static clojure.lang.Var const__30;
 private static java.lang.Integer const__31;
 private static clojure.lang.IPersistentList const__32;
 private static clojure.lang.IPersistentMap const__33;
 private static clojure.lang.Var const__34;
 private static java.lang.Integer const__35;
 private static clojure.lang.IPersistentList const__36;
 private static clojure.lang.IPersistentMap const__37;
 private static clojure.lang.Var const__38;
 private static java.lang.Integer const__39;
 private static clojure.lang.IPersistentList const__40;
 private static clojure.lang.IPersistentMap const__41;
 private static clojure.lang.Var const__42;
 private static clojure.lang.Var const__43;
 private static clojure.lang.Var const__44;
 private static clojure.lang.Var const__45;
 private static clojure.lang.IPersistentList const__46;
 private static clojure.lang.Var const__47;
 private static clojure.lang.Var const__48;
 private static clojure.lang.Keyword const__49;
 private static clojure.lang.Symbol const__50;
 private static clojure.lang.Keyword const__51;
 private static java.lang.Class const__52;
 private static clojure.lang.IPersistentMap const__53;
 private static clojure.lang.Keyword const__54;
 private static clojure.lang.IPersistentMap const__55;
 private static clojure.lang.Keyword const__56;
 private static clojure.lang.Keyword const__57;
 private static clojure.lang.Keyword const__58;
 private static clojure.lang.IPersistentMap const__59;
 private static clojure.lang.Keyword const__60;
 private static clojure.lang.Var const__61;
 private static clojure.lang.Var const__62;
 private static clojure.lang.Var const__63;
 private static clojure.lang.Symbol const__64;
 private static clojure.lang.IPersistentMap const__65;
 private static clojure.lang.Keyword const__66;
 private static clojure.lang.Var const__67;
 private static clojure.lang.Symbol const__68;
 private static clojure.lang.Var const__69;
 private static java.lang.Integer const__70;
 private static clojure.lang.IPersistentList const__71;
 private static clojure.lang.Keyword const__72;
 private static clojure.lang.IPersistentMap const__73;
 private static clojure.lang.Var const__74;
 private static java.lang.Integer const__75;
 private static clojure.lang.IPersistentList const__76;
 private static clojure.lang.IPersistentMap const__77;
 private static clojure.lang.Var const__78;
 private static java.lang.Integer const__79;
 private static clojure.lang.IPersistentList const__80;
 private static clojure.lang.IPersistentMap const__81;
 private static clojure.lang.Var const__82;
 private static java.lang.Integer const__83;
 private static clojure.lang.IPersistentList const__84;
 private static clojure.lang.IPersistentMap const__85;
 private static clojure.lang.Var const__86;
 private static java.lang.Integer const__87;
 private static clojure.lang.IPersistentList const__88;
 private static clojure.lang.IPersistentMap const__89;
 private static clojure.lang.Var const__90;
 private static java.lang.Integer const__91;
 private static clojure.lang.IPersistentList const__92;
 private static clojure.lang.IPersistentMap const__93;
 private static clojure.lang.Var const__94;
 private static java.lang.Integer const__95;
 private static clojure.lang.IPersistentList const__96;
 private static clojure.lang.IPersistentMap const__97;
 private static clojure.lang.Var const__98;
 private static java.lang.Integer const__99;
 private static clojure.lang.IPersistentList const__100;
 private static clojure.lang.IPersistentMap const__101;
 private static clojure.lang.Var const__102;
 private static java.lang.Integer const__103;
 private static clojure.lang.IPersistentList const__104;
 private static clojure.lang.IPersistentMap const__105;
 private static clojure.lang.Var const__106;
 private static java.lang.Integer const__107;
 private static clojure.lang.IPersistentList const__108;
 private static clojure.lang.IPersistentMap const__109;
 private static clojure.lang.Var const__110;
 private static java.lang.Integer const__111;
 private static clojure.lang.IPersistentList const__112;
 private static clojure.lang.IPersistentMap const__113;
 private static clojure.lang.Var const__114;
 private static java.lang.Integer const__115;
 private static clojure.lang.IPersistentList const__116;
 private static clojure.lang.IPersistentMap const__117;
 private static clojure.lang.Var const__118;
 private static java.lang.Integer const__119;
 private static clojure.lang.IPersistentList const__120;
 private static clojure.lang.IPersistentMap const__121;
 private static clojure.lang.Var const__122;
 private static java.lang.Integer const__123;
 private static clojure.lang.IPersistentList const__124;
 private static clojure.lang.IPersistentMap const__125;
 private static clojure.lang.Var const__126;
 private static java.lang.Integer const__127;
 private static clojure.lang.IPersistentList const__128;
 private static clojure.lang.IPersistentMap const__129;
 private static clojure.lang.Var const__130;
 private static java.lang.Integer const__131;
 private static clojure.lang.IPersistentList const__132;
 private static clojure.lang.IPersistentMap const__133;
 private static clojure.lang.Var const__134;
 private static java.lang.Integer const__135;
 private static clojure.lang.IPersistentList const__136;
 private static clojure.lang.IPersistentMap const__137;
 private static clojure.lang.Var const__138;
 private static java.lang.Integer const__139;
 private static clojure.lang.IPersistentList const__140;
 private static clojure.lang.IPersistentMap const__141;
 private static clojure.lang.Var const__142;
 private static java.lang.Integer const__143;
 private static clojure.lang.IPersistentList const__144;
 private static clojure.lang.IPersistentMap const__145;
 private static clojure.lang.Var const__146;
 private static java.lang.Integer const__147;
 private static clojure.lang.IPersistentList const__148;
 private static clojure.lang.IPersistentMap const__149;
 private static clojure.lang.Var const__150;
 private static java.lang.Class const__151;
 private static java.lang.Class const__152;
 private static java.lang.Class const__153;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "clojure.core.reducers")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "author"), "Rich Hickey", Keyword.intern(null, "doc"), "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require Java 7+ or\n      Java 6 + jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info."));
  const__2 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__3 = (clojure.lang.Var)RT.var("clojure.core", "alias");
  const__4 = (clojure.lang.Symbol)Symbol.intern(null, "core");
  const__5 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__6 = (clojure.lang.Var)RT.var("clojure.core", "*warn-on-reflection*");
  const__7 = (clojure.lang.Var)RT.var("clojure.core.reducers", "compile-if");
  const__8 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__9 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__10 = (java.lang.Integer)1;
  const__11 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__12 = (java.lang.Integer)24;
  const__13 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__14 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "exp"), Symbol.intern(null, "then"), Symbol.intern(null, "else"))));
  const__15 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__16 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__17 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "exp"), Symbol.intern(null, "then"), Symbol.intern(null, "else")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Evaluate `exp` and if it returns logical true and doesn't error, expand to\n  `then`.  Else expand to `else`.\n\n  (compile-if (Class/forName \"java.util.concurrent.ForkJoinTask\")\n    (do-cool-stuff-with-fork-join)\n    (fall-back-to-executor-services))", Keyword.intern(null, "line"), 24, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__18 = (clojure.lang.Var)RT.var("clojure.core.reducers", "pool");
  const__19 = (java.lang.Integer)4;
  const__20 = (java.lang.Integer)41;
  const__21 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 4, Keyword.intern(null, "line"), 41, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__22 = (clojure.lang.Var)RT.var("clojure.core.reducers", "fjtask");
  const__23 = (java.lang.Integer)43;
  const__24 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Callable"))))));
  const__25 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "f")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Callable")))))), Keyword.intern(null, "column"), 4, Keyword.intern(null, "line"), 43, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__26 = (clojure.lang.Var)RT.var("clojure.core.reducers", "fjinvoke");
  const__27 = (java.lang.Integer)46;
  const__28 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f"))));
  const__29 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f")))), Keyword.intern(null, "column"), 4, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 46, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__30 = (clojure.lang.Var)RT.var("clojure.core.reducers", "fjfork");
  const__31 = (java.lang.Integer)51;
  const__32 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "task"))));
  const__33 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "task")))), Keyword.intern(null, "column"), 4, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 51, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__34 = (clojure.lang.Var)RT.var("clojure.core.reducers", "fjjoin");
  const__35 = (java.lang.Integer)53;
  const__36 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "task"))));
  const__37 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "task")))), Keyword.intern(null, "column"), 4, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 53, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__38 = (clojure.lang.Var)RT.var("clojure.core.reducers", "reduce");
  const__39 = (java.lang.Integer)71;
  const__40 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "coll"))));
  const__41 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "init"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv", Keyword.intern(null, "line"), 71, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__42 = (clojure.lang.Var)RT.var("clojure.core", "alter-meta!");
  const__43 = (clojure.lang.Var)RT.var("clojure.core.reducers", "CollFold");
  const__44 = (clojure.lang.Var)RT.var("clojure.core", "assoc");
  const__45 = (clojure.lang.Var)RT.var("clojure.core", "assert-same-protocol");
  const__46 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(((clojure.lang.IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "doc"), null))));
  const__47 = (clojure.lang.Var)RT.var("clojure.core", "alter-var-root");
  const__48 = (clojure.lang.Var)RT.var("clojure.core", "merge");
  const__49 = (clojure.lang.Keyword)Keyword.intern(null, "on");
  const__50 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core.reducers.CollFold");
  const__51 = (clojure.lang.Keyword)Keyword.intern(null, "on-interface");
  const__52 = (java.lang.Class)clojure.core.reducers.CollFold.class;
  const__53 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "on"), Symbol.intern(null, "clojure.core.reducers.CollFold"), Keyword.intern(null, "on-interface"), clojure.core.reducers.CollFold.class);
  const__54 = (clojure.lang.Keyword)Keyword.intern(null, "sigs");
  const__55 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "coll-fold"), RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "doc"), null))));
  const__56 = (clojure.lang.Keyword)Keyword.intern(null, "var");
  const__57 = (clojure.lang.Keyword)Keyword.intern(null, "method-map");
  const__58 = (clojure.lang.Keyword)Keyword.intern(null, "coll-fold");
  const__59 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "coll-fold"), Keyword.intern(null, "coll-fold"));
  const__60 = (clojure.lang.Keyword)Keyword.intern(null, "method-builders");
  const__61 = (clojure.lang.Var)RT.var("clojure.core", "intern");
  const__62 = (clojure.lang.Var)RT.var("clojure.core", "*ns*");
  const__63 = (clojure.lang.Var)RT.var("clojure.core", "with-meta");
  const__64 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "doc"), null));
  const__65 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "doc"), null, Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "coll-fold")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "doc"), null)));
  const__66 = (clojure.lang.Keyword)Keyword.intern(null, "protocol");
  const__67 = (clojure.lang.Var)RT.var("clojure.core", "-reset-methods");
  const__68 = (clojure.lang.Symbol)Symbol.intern(null, "CollFold");
  const__69 = (clojure.lang.Var)RT.var("clojure.core.reducers", "fold");
  const__70 = (java.lang.Integer)84;
  const__71 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"), Symbol.intern(null, "coll"))));
  const__72 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__73 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.", Keyword.intern(null, "line"), 84, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__74 = (clojure.lang.Var)RT.var("clojure.core.reducers", "reducer");
  const__75 = (java.lang.Integer)100;
  const__76 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "xf"))));
  const__77 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "xf")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", Keyword.intern(null, "line"), 100, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__78 = (clojure.lang.Var)RT.var("clojure.core.reducers", "folder");
  const__79 = (java.lang.Integer)114;
  const__80 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "xf"))));
  const__81 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"), Symbol.intern(null, "xf")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", Keyword.intern(null, "line"), 114, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__82 = (clojure.lang.Var)RT.var("clojure.core.reducers", "do-curried");
  const__83 = (java.lang.Integer)132;
  const__84 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "doc"), Symbol.intern(null, "meta"), Symbol.intern(null, "args"), Symbol.intern(null, "body"))));
  const__85 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "doc"), Symbol.intern(null, "meta"), Symbol.intern(null, "args"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 132, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__86 = (clojure.lang.Var)RT.var("clojure.core.reducers", "defcurried");
  const__87 = (java.lang.Integer)139;
  const__88 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "doc"), Symbol.intern(null, "meta"), Symbol.intern(null, "args"), Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__89 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "doc"), Symbol.intern(null, "meta"), Symbol.intern(null, "args"), Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Builds another arity of the fn that returns a fn awaiting the last\n  param", Keyword.intern(null, "line"), 139, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__90 = (clojure.lang.Var)RT.var("clojure.core.reducers", "do-rfn");
  const__91 = (java.lang.Integer)145;
  const__92 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f1"), Symbol.intern(null, "k"), Symbol.intern(null, "fkv"))));
  const__93 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f1"), Symbol.intern(null, "k"), Symbol.intern(null, "fkv")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 145, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__94 = (clojure.lang.Var)RT.var("clojure.core.reducers", "rfn");
  const__95 = (java.lang.Integer)156;
  const__96 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "f1"), Symbol.intern(null, "k")), Symbol.intern(null, "fkv"))));
  const__97 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "f1"), Symbol.intern(null, "k")), Symbol.intern(null, "fkv")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", Keyword.intern(null, "line"), 156, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__98 = (clojure.lang.Var)RT.var("clojure.core.reducers", "map");
  const__99 = (java.lang.Integer)161;
 }
 static void __init1() {
  const__100 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "coll"))));
  const__101 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Applies f to every value in the reduction of coll. Foldable.", Keyword.intern(null, "line"), 161, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__102 = (clojure.lang.Var)RT.var("clojure.core.reducers", "mapcat");
  const__103 = (java.lang.Integer)171;
  const__104 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "coll"))));
  const__105 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "f")), RT.vector(Symbol.intern(null, "f"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.", Keyword.intern(null, "line"), 171, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__106 = (clojure.lang.Var)RT.var("clojure.core.reducers", "filter");
  const__107 = (java.lang.Integer)187;
  const__108 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "pred")), RT.vector(Symbol.intern(null, "pred"), Symbol.intern(null, "coll"))));
  const__109 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "pred")), RT.vector(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", Keyword.intern(null, "line"), 187, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__110 = (clojure.lang.Var)RT.var("clojure.core.reducers", "remove");
  const__111 = (java.lang.Integer)200;
  const__112 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "pred")), RT.vector(Symbol.intern(null, "pred"), Symbol.intern(null, "coll"))));
  const__113 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "pred")), RT.vector(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", Keyword.intern(null, "line"), 200, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__114 = (clojure.lang.Var)RT.var("clojure.core.reducers", "flatten");
  const__115 = (java.lang.Integer)207;
  const__116 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "coll"))));
  const__117 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.", Keyword.intern(null, "line"), 207, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__118 = (clojure.lang.Var)RT.var("clojure.core.reducers", "take-while");
  const__119 = (java.lang.Integer)222;
  const__120 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "pred")), RT.vector(Symbol.intern(null, "pred"), Symbol.intern(null, "coll"))));
  const__121 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "pred")), RT.vector(Symbol.intern(null, "pred"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Ends the reduction of coll when (pred val) returns logical false.", Keyword.intern(null, "line"), 222, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__122 = (clojure.lang.Var)RT.var("clojure.core.reducers", "take");
  const__123 = (java.lang.Integer)234;
  const__124 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "n")), RT.vector(Symbol.intern(null, "n"), Symbol.intern(null, "coll"))));
  const__125 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "n")), RT.vector(Symbol.intern(null, "n"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Ends the reduction of coll after consuming n values.", Keyword.intern(null, "line"), 234, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__126 = (clojure.lang.Var)RT.var("clojure.core.reducers", "drop");
  const__127 = (java.lang.Integer)248;
  const__128 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "n")), RT.vector(Symbol.intern(null, "n"), Symbol.intern(null, "coll"))));
  const__129 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "n")), RT.vector(Symbol.intern(null, "n"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Elides the first n values from the reduction of coll.", Keyword.intern(null, "line"), 248, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__130 = (clojure.lang.Var)RT.var("clojure.core.reducers", "cat");
  const__131 = (java.lang.Integer)288;
  const__132 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "ctor")), RT.vector(Symbol.intern(null, "left"), Symbol.intern(null, "right"))));
  const__133 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "ctor")), RT.vector(Symbol.intern(null, "left"), Symbol.intern(null, "right")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.", Keyword.intern(null, "line"), 288, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__134 = (clojure.lang.Var)RT.var("clojure.core.reducers", "append!");
  const__135 = (java.lang.Integer)308;
  const__136 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "acc")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "java.util.Collection"))), Symbol.intern(null, "x"))));
  const__137 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "acc")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "java.util.Collection"))), Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), ".adds x to acc and returns acc", Keyword.intern(null, "line"), 308, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__138 = (clojure.lang.Var)RT.var("clojure.core.reducers", "foldcat");
  const__139 = (java.lang.Integer)314;
  const__140 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll"))));
  const__141 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Equivalent to (fold cat append! coll)", Keyword.intern(null, "line"), 314, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__142 = (clojure.lang.Var)RT.var("clojure.core.reducers", "monoid");
  const__143 = (java.lang.Integer)320;
  const__144 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "op"), Symbol.intern(null, "ctor"))));
  const__145 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "op"), Symbol.intern(null, "ctor")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.", Keyword.intern(null, "line"), 320, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__146 = (clojure.lang.Var)RT.var("clojure.core.reducers", "foldvec");
  const__147 = (java.lang.Integer)331;
  const__148 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "v"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef"))));
  const__149 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "v"), Symbol.intern(null, "n"), Symbol.intern(null, "combinef"), Symbol.intern(null, "reducef")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 331, Keyword.intern(null, "file"), "clojure/core/reducers.clj");
  const__150 = (clojure.lang.Var)RT.var("clojure.core", "extend");
  const__151 = (java.lang.Class)clojure.lang.PersistentHashMap.class;
  const__152 = (java.lang.Class)clojure.lang.IPersistentVector.class;
  const__153 = (java.lang.Class)java.lang.Object.class;
 }
 static {
  __init0();
  __init1();
  clojure.lang.Compiler.pushNSandLoader(clojure.core.reducers__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
