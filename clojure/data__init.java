package clojure;

import clojure.lang.*;

public class data__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((IFn)new clojure.data_loading__4931__auto__()).invoke();
  if (((clojure.lang.Symbol)const__1).equals(((java.lang.Object)const__2))) {
  } else {
   clojure.lang.LockingTransaction.runInTransaction((java.util.concurrent.Callable)((java.util.concurrent.Callable)new clojure.data_fn__8785()));
  }
  const__3.setMeta((IPersistentMap)const__10);
  const__11.setMeta((IPersistentMap)const__17);
  const__11.bindRoot(new clojure.data_atom_diff());
  const__18.setMeta((IPersistentMap)const__21);
  const__18.bindRoot(new clojure.data_vectorize());
  const__22.setMeta((IPersistentMap)const__25);
  const__22.bindRoot(new clojure.data_diff_associative_key());
  const__26.setMeta((IPersistentMap)const__29);
  const__26.bindRoot(new clojure.data_diff_associative());
  const__30.setMeta((IPersistentMap)const__33);
  const__30.bindRoot(new clojure.data_diff_sequential());
  ((IFn)new clojure.data_fn__8809()).invoke();
  ((IFn)const__34.getRawRoot()).invoke(const__35, const__36.getRawRoot(), const__15, "Implementation detail. Subject to change.");
  ((IFn)const__37).invoke(const__35, const__38);
  ((IFn)const__39.getRawRoot()).invoke(const__35, const__40.getRawRoot(), ((IFn)const__36.getRawRoot()).invoke(const__45, const__46, const__47, const__48, const__35, const__49, const__51, const__52, RT.mapUniqueKeys(((IFn)const__53.getRawRoot()).invoke(const__54.get(), ((IFn)const__55.getRawRoot()).invoke(const__56, ((IFn)const__40.getRawRoot()).invoke(const__57, RT.mapUniqueKeys(const__58, const__35)))), new clojure.data_fn__8812())));
  ((IFn)const__59.getRawRoot()).invoke(const__35.getRawRoot());
  ((IFn)new clojure.data_fn__8825()).invoke();
  ((IFn)const__34.getRawRoot()).invoke(const__61, const__36.getRawRoot(), const__15, "Implementation detail. Subject to change.");
  ((IFn)const__37).invoke(const__61, const__62);
  ((IFn)const__39.getRawRoot()).invoke(const__61, const__40.getRawRoot(), ((IFn)const__36.getRawRoot()).invoke(const__65, const__46, const__66, const__48, const__61, const__49, const__68, const__52, RT.mapUniqueKeys(((IFn)const__53.getRawRoot()).invoke(const__54.get(), ((IFn)const__55.getRawRoot()).invoke(const__69, ((IFn)const__40.getRawRoot()).invoke(const__70, RT.mapUniqueKeys(const__58, const__61)))), new clojure.data_fn__8828())));
  ((IFn)const__59.getRawRoot()).invoke(const__61.getRawRoot());
  ((IFn)const__72.getRawRoot()).invoke(null, const__61.getRawRoot(), RT.mapUniqueKeys(const__67, const__11.getRawRoot()));
  ((IFn)const__72.getRawRoot()).invoke(const__73, const__61.getRawRoot(), RT.mapUniqueKeys(const__67, new clojure.data_fn__8841()), const__35.getRawRoot(), RT.mapUniqueKeys(const__50, new clojure.data_fn__8843()));
  ((IFn)const__72.getRawRoot()).invoke(const__74, const__35.getRawRoot(), RT.mapUniqueKeys(const__50, new clojure.data_fn__8845()));
  ((IFn)const__72.getRawRoot()).invoke(const__75, const__35.getRawRoot(), RT.mapUniqueKeys(const__50, new clojure.data_fn__8847()));
  ((IFn)const__72.getRawRoot()).invoke(const__76, const__35.getRawRoot(), RT.mapUniqueKeys(const__50, new clojure.data_fn__8849()));
  ((IFn)const__72.getRawRoot()).invoke(null, const__35.getRawRoot(), RT.mapUniqueKeys(const__50, new clojure.data_fn__8851()));
  const__77.setMeta((IPersistentMap)const__80);
  const__77.bindRoot(new clojure.data_as_set_value());
  ((IFn)const__72.getRawRoot()).invoke(const__74, const__61.getRawRoot(), RT.mapUniqueKeys(const__67, new clojure.data_fn__8854()));
  ((IFn)const__72.getRawRoot()).invoke(const__75, const__61.getRawRoot(), RT.mapUniqueKeys(const__67, new clojure.data_fn__8856()));
  ((IFn)const__72.getRawRoot()).invoke(const__76, const__61.getRawRoot(), RT.mapUniqueKeys(const__67, new clojure.data_fn__8858()));
  const__3.setMeta((IPersistentMap)const__84);
  const__3.bindRoot(new clojure.data_diff());
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Symbol const__2;
 private static clojure.lang.Var const__3;
 private static clojure.lang.Keyword const__4;
 private static clojure.lang.Keyword const__5;
 private static java.lang.Integer const__6;
 private static clojure.lang.Keyword const__7;
 private static java.lang.Integer const__8;
 private static clojure.lang.Keyword const__9;
 private static clojure.lang.IPersistentMap const__10;
 private static clojure.lang.Var const__11;
 private static java.lang.Integer const__12;
 private static clojure.lang.Keyword const__13;
 private static clojure.lang.IPersistentList const__14;
 private static clojure.lang.Keyword const__15;
 private static clojure.lang.Keyword const__16;
 private static clojure.lang.IPersistentMap const__17;
 private static clojure.lang.Var const__18;
 private static java.lang.Integer const__19;
 private static clojure.lang.IPersistentList const__20;
 private static clojure.lang.IPersistentMap const__21;
 private static clojure.lang.Var const__22;
 private static java.lang.Integer const__23;
 private static clojure.lang.IPersistentList const__24;
 private static clojure.lang.IPersistentMap const__25;
 private static clojure.lang.Var const__26;
 private static java.lang.Integer const__27;
 private static clojure.lang.IPersistentList const__28;
 private static clojure.lang.IPersistentMap const__29;
 private static clojure.lang.Var const__30;
 private static java.lang.Integer const__31;
 private static clojure.lang.IPersistentList const__32;
 private static clojure.lang.IPersistentMap const__33;
 private static clojure.lang.Var const__34;
 private static clojure.lang.Var const__35;
 private static clojure.lang.Var const__36;
 private static clojure.lang.Var const__37;
 private static clojure.lang.IPersistentList const__38;
 private static clojure.lang.Var const__39;
 private static clojure.lang.Var const__40;
 private static clojure.lang.Keyword const__41;
 private static clojure.lang.Symbol const__42;
 private static clojure.lang.Keyword const__43;
 private static java.lang.Class const__44;
 private static clojure.lang.IPersistentMap const__45;
 private static clojure.lang.Keyword const__46;
 private static clojure.lang.IPersistentMap const__47;
 private static clojure.lang.Keyword const__48;
 private static clojure.lang.Keyword const__49;
 private static clojure.lang.Keyword const__50;
 private static clojure.lang.IPersistentMap const__51;
 private static clojure.lang.Keyword const__52;
 private static clojure.lang.Var const__53;
 private static clojure.lang.Var const__54;
 private static clojure.lang.Var const__55;
 private static clojure.lang.Symbol const__56;
 private static clojure.lang.IPersistentMap const__57;
 private static clojure.lang.Keyword const__58;
 private static clojure.lang.Var const__59;
 private static clojure.lang.Symbol const__60;
 private static clojure.lang.Var const__61;
 private static clojure.lang.IPersistentList const__62;
 private static clojure.lang.Symbol const__63;
 private static java.lang.Class const__64;
 private static clojure.lang.IPersistentMap const__65;
 private static clojure.lang.IPersistentMap const__66;
 private static clojure.lang.Keyword const__67;
 private static clojure.lang.IPersistentMap const__68;
 private static clojure.lang.Symbol const__69;
 private static clojure.lang.IPersistentMap const__70;
 private static clojure.lang.Symbol const__71;
 private static clojure.lang.Var const__72;
 private static java.lang.Class const__73;
 private static java.lang.Class const__74;
 private static java.lang.Class const__75;
 private static java.lang.Class const__76;
 private static clojure.lang.Var const__77;
 private static java.lang.Integer const__78;
 private static clojure.lang.IPersistentList const__79;
 private static clojure.lang.IPersistentMap const__80;
 private static java.lang.Integer const__81;
 private static clojure.lang.IPersistentList const__82;
 private static clojure.lang.Keyword const__83;
 private static clojure.lang.IPersistentMap const__84;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "clojure.data")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "doc"), "Non-core data functions.", Keyword.intern(null, "author"), "Stuart Halloway"));
  const__2 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__3 = (clojure.lang.Var)RT.var("clojure.data", "diff");
  const__4 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__5 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__6 = (java.lang.Integer)1;
  const__7 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__8 = (java.lang.Integer)15;
  const__9 = (clojure.lang.Keyword)Keyword.intern(null, "declared");
  const__10 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "declared"), Boolean.TRUE, Keyword.intern(null, "line"), 15, Keyword.intern(null, "file"), "clojure/data.clj");
  const__11 = (clojure.lang.Var)RT.var("clojure.data", "atom-diff");
  const__12 = (java.lang.Integer)17;
  const__13 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__14 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"))));
  const__15 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__16 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__17 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Internal helper for diff.", Keyword.intern(null, "line"), 17, Keyword.intern(null, "file"), "clojure/data.clj");
  const__18 = (clojure.lang.Var)RT.var("clojure.data", "vectorize");
  const__19 = (java.lang.Integer)23;
  const__20 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "m"))));
  const__21 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "m")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys", Keyword.intern(null, "line"), 23, Keyword.intern(null, "file"), "clojure/data.clj");
  const__22 = (clojure.lang.Var)RT.var("clojure.data", "diff-associative-key");
  const__23 = (java.lang.Integer)33;
  const__24 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "k"))));
  const__25 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "k")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Diff associative things a and b, comparing only the key k.", Keyword.intern(null, "line"), 33, Keyword.intern(null, "file"), "clojure/data.clj");
  const__26 = (clojure.lang.Var)RT.var("clojure.data", "diff-associative");
  const__27 = (java.lang.Integer)49;
  const__28 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "ks"))));
  const__29 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"), Symbol.intern(null, "ks")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Diff associative things a and b, comparing only keys in ks.", Keyword.intern(null, "line"), 49, Keyword.intern(null, "file"), "clojure/data.clj");
  const__30 = (clojure.lang.Var)RT.var("clojure.data", "diff-sequential");
  const__31 = (java.lang.Integer)60;
  const__32 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"))));
  const__33 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 60, Keyword.intern(null, "file"), "clojure/data.clj");
  const__34 = (clojure.lang.Var)RT.var("clojure.core", "alter-meta!");
  const__35 = (clojure.lang.Var)RT.var("clojure.data", "EqualityPartition");
  const__36 = (clojure.lang.Var)RT.var("clojure.core", "assoc");
  const__37 = (clojure.lang.Var)RT.var("clojure.core", "assert-same-protocol");
  const__38 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(((clojure.lang.IObj)Symbol.intern(null, "equality-partition")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change."))));
  const__39 = (clojure.lang.Var)RT.var("clojure.core", "alter-var-root");
  const__40 = (clojure.lang.Var)RT.var("clojure.core", "merge");
  const__41 = (clojure.lang.Keyword)Keyword.intern(null, "on");
  const__42 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.data.EqualityPartition");
  const__43 = (clojure.lang.Keyword)Keyword.intern(null, "on-interface");
  const__44 = (java.lang.Class)clojure.data.EqualityPartition.class;
  const__45 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "on"), Symbol.intern(null, "clojure.data.EqualityPartition"), Keyword.intern(null, "doc"), "Implementation detail. Subject to change.", Keyword.intern(null, "on-interface"), clojure.data.EqualityPartition.class);
  const__46 = (clojure.lang.Keyword)Keyword.intern(null, "sigs");
  const__47 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "equality-partition"), RT.map(Keyword.intern(null, "doc"), "Implementation detail. Subject to change.", Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "equality-partition")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change.")), Keyword.intern(null, "added"), "1.3"));
  const__48 = (clojure.lang.Keyword)Keyword.intern(null, "var");
  const__49 = (clojure.lang.Keyword)Keyword.intern(null, "method-map");
  const__50 = (clojure.lang.Keyword)Keyword.intern(null, "equality-partition");
  const__51 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "equality-partition"), Keyword.intern(null, "equality-partition"));
  const__52 = (clojure.lang.Keyword)Keyword.intern(null, "method-builders");
  const__53 = (clojure.lang.Var)RT.var("clojure.core", "intern");
  const__54 = (clojure.lang.Var)RT.var("clojure.core", "*ns*");
  const__55 = (clojure.lang.Var)RT.var("clojure.core", "with-meta");
  const__56 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "equality-partition")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change."));
  const__57 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "doc"), "Implementation detail. Subject to change.", Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "equality-partition")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change.")), Keyword.intern(null, "added"), "1.3");
  const__58 = (clojure.lang.Keyword)Keyword.intern(null, "protocol");
  const__59 = (clojure.lang.Var)RT.var("clojure.core", "-reset-methods");
  const__60 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "EqualityPartition")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "added"), "1.3"));
  const__61 = (clojure.lang.Var)RT.var("clojure.data", "Diff");
  const__62 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(((clojure.lang.IObj)Symbol.intern(null, "diff-similar")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change."))));
  const__63 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.data.Diff");
  const__64 = (java.lang.Class)clojure.data.Diff.class;
  const__65 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "on"), Symbol.intern(null, "clojure.data.Diff"), Keyword.intern(null, "doc"), "Implementation detail. Subject to change.", Keyword.intern(null, "on-interface"), clojure.data.Diff.class);
  const__66 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "diff-similar"), RT.map(Keyword.intern(null, "doc"), "Implementation detail. Subject to change.", Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "diff-similar")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change.")), Keyword.intern(null, "added"), "1.3"));
  const__67 = (clojure.lang.Keyword)Keyword.intern(null, "diff-similar");
  const__68 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "diff-similar"), Keyword.intern(null, "diff-similar"));
  const__69 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "diff-similar")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change."));
  const__70 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "doc"), "Implementation detail. Subject to change.", Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "name"), ((clojure.lang.IObj)Symbol.intern(null, "diff-similar")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "doc"), "Implementation detail. Subject to change.")), Keyword.intern(null, "added"), "1.3");
  const__71 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "Diff")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "added"), "1.3"));
  const__72 = (clojure.lang.Var)RT.var("clojure.core", "extend");
  const__73 = (java.lang.Class)java.lang.Object.class;
  const__74 = (java.lang.Class)java.util.Map.class;
  const__75 = (java.lang.Class)java.util.List.class;
  const__76 = (java.lang.Class)java.util.Set.class;
  const__77 = (clojure.lang.Var)RT.var("clojure.data", "as-set-value");
  const__78 = (java.lang.Integer)98;
  const__79 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s"))));
  const__80 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 98, Keyword.intern(null, "file"), "clojure/data.clj");
  const__81 = (java.lang.Integer)120;
  const__82 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b"))));
  const__83 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__84 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "a"), Symbol.intern(null, "b")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.3", Keyword.intern(null, "doc"), "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.", Keyword.intern(null, "line"), 120, Keyword.intern(null, "file"), "clojure/data.clj");
 }
 static {
  __init0();
  clojure.lang.Compiler.pushNSandLoader(clojure.data__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
