package clojure;

import clojure.lang.*;

public class main__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((IFn)new clojure.main_loading__4931__auto__()).invoke();
  if (((clojure.lang.Symbol)const__1).equals(((java.lang.Object)const__2))) {
  } else {
   clojure.lang.LockingTransaction.runInTransaction((java.util.concurrent.Callable)((java.util.concurrent.Callable)new clojure.main_fn__6765()));
  }
  const__3.setMeta((IPersistentMap)const__10);
  const__11.setMeta((IPersistentMap)const__17);
  const__11.bindRoot(new clojure.main_demunge());
  const__18.setMeta((IPersistentMap)const__21);
  const__18.bindRoot(new clojure.main_root_cause());
  const__22.setMeta((IPersistentMap)const__25);
  const__22.bindRoot(new clojure.main_stack_element_str());
  const__26.setMeta((IPersistentMap)const__29);
  const__26.bindRoot(new clojure.main_with_bindings());
  ((clojure.lang.Var)const__26).setMacro();
  const__30.setMeta((IPersistentMap)const__33);
  const__30.bindRoot(new clojure.main_repl_prompt());
  const__34.setMeta((IPersistentMap)const__37);
  const__34.bindRoot(new clojure.main_skip_if_eol());
  const__38.setMeta((IPersistentMap)const__41);
  const__38.bindRoot(new clojure.main_skip_whitespace());
  const__42.setMeta((IPersistentMap)const__45);
  const__42.bindRoot(new clojure.main_repl_read());
  const__46.setMeta((IPersistentMap)const__49);
  const__46.bindRoot(new clojure.main_repl_exception());
  const__50.setMeta((IPersistentMap)const__53);
  const__50.bindRoot(new clojure.main_repl_caught());
  const__54.setMeta((IPersistentMap)const__56);
  const__54.bindRoot(const__57);
  const__58.setMeta((IPersistentMap)const__61);
  const__58.bindRoot(new clojure.main_with_read_known());
  ((clojure.lang.Var)const__58).setMacro();
  const__62.setMeta((IPersistentMap)const__65);
  const__62.bindRoot(new clojure.main_repl());
  const__66.setMeta((IPersistentMap)const__69);
  const__66.bindRoot(new clojure.main_load_script());
  const__70.setMeta((IPersistentMap)const__74);
  const__70.bindRoot(new clojure.main_init_opt());
  const__75.setMeta((IPersistentMap)const__78);
  const__75.bindRoot(new clojure.main_eval_opt());
  const__79.setMeta((IPersistentMap)const__82);
  const__79.bindRoot(new clojure.main_init_dispatch());
  const__83.setMeta((IPersistentMap)const__86);
  const__83.bindRoot(new clojure.main_initialize());
  const__87.setMeta((IPersistentMap)const__90);
  const__87.bindRoot(new clojure.main_main_opt());
  const__91.setMeta((IPersistentMap)const__94);
  const__91.bindRoot(new clojure.main_repl_opt());
  const__95.setMeta((IPersistentMap)const__98);
  const__95.bindRoot(new clojure.main_script_opt());
  const__99.setMeta((IPersistentMap)const__102);
  const__99.bindRoot(new clojure.main_null_opt());
  const__103.setMeta((IPersistentMap)const__106);
  const__103.bindRoot(new clojure.main_help_opt());
  const__107.setMeta((IPersistentMap)const__110);
  const__107.bindRoot(new clojure.main_main_dispatch());
  const__111.setMeta((IPersistentMap)const__114);
  const__111.bindRoot(new clojure.main_legacy_repl());
  const__115.setMeta((IPersistentMap)const__118);
  const__115.bindRoot(new clojure.main_legacy_script());
  const__3.setMeta((IPersistentMap)const__121);
  const__3.bindRoot(new clojure.main_main());
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Symbol const__2;
 private static clojure.lang.Var const__3;
 private static clojure.lang.Keyword const__4;
 private static clojure.lang.Keyword const__5;
 private static java.lang.Integer const__6;
 private static clojure.lang.Keyword const__7;
 private static java.lang.Integer const__8;
 private static clojure.lang.Keyword const__9;
 private static clojure.lang.IPersistentMap const__10;
 private static clojure.lang.Var const__11;
 private static java.lang.Integer const__12;
 private static clojure.lang.Keyword const__13;
 private static clojure.lang.IPersistentList const__14;
 private static clojure.lang.Keyword const__15;
 private static clojure.lang.Keyword const__16;
 private static clojure.lang.IPersistentMap const__17;
 private static clojure.lang.Var const__18;
 private static java.lang.Integer const__19;
 private static clojure.lang.IPersistentList const__20;
 private static clojure.lang.IPersistentMap const__21;
 private static clojure.lang.Var const__22;
 private static java.lang.Integer const__23;
 private static clojure.lang.IPersistentList const__24;
 private static clojure.lang.IPersistentMap const__25;
 private static clojure.lang.Var const__26;
 private static java.lang.Integer const__27;
 private static clojure.lang.IPersistentList const__28;
 private static clojure.lang.IPersistentMap const__29;
 private static clojure.lang.Var const__30;
 private static java.lang.Integer const__31;
 private static clojure.lang.IPersistentList const__32;
 private static clojure.lang.IPersistentMap const__33;
 private static clojure.lang.Var const__34;
 private static java.lang.Integer const__35;
 private static clojure.lang.IPersistentList const__36;
 private static clojure.lang.IPersistentMap const__37;
 private static clojure.lang.Var const__38;
 private static java.lang.Integer const__39;
 private static clojure.lang.IPersistentList const__40;
 private static clojure.lang.IPersistentMap const__41;
 private static clojure.lang.Var const__42;
 private static java.lang.Integer const__43;
 private static clojure.lang.IPersistentList const__44;
 private static clojure.lang.IPersistentMap const__45;
 private static clojure.lang.Var const__46;
 private static java.lang.Integer const__47;
 private static clojure.lang.IPersistentList const__48;
 private static clojure.lang.IPersistentMap const__49;
 private static clojure.lang.Var const__50;
 private static java.lang.Integer const__51;
 private static clojure.lang.IPersistentList const__52;
 private static clojure.lang.IPersistentMap const__53;
 private static clojure.lang.Var const__54;
 private static java.lang.Integer const__55;
 private static clojure.lang.IPersistentMap const__56;
 private static clojure.lang.PersistentVector const__57;
 private static clojure.lang.Var const__58;
 private static java.lang.Integer const__59;
 private static clojure.lang.IPersistentList const__60;
 private static clojure.lang.IPersistentMap const__61;
 private static clojure.lang.Var const__62;
 private static java.lang.Integer const__63;
 private static clojure.lang.IPersistentList const__64;
 private static clojure.lang.IPersistentMap const__65;
 private static clojure.lang.Var const__66;
 private static java.lang.Integer const__67;
 private static clojure.lang.IPersistentList const__68;
 private static clojure.lang.IPersistentMap const__69;
 private static clojure.lang.Var const__70;
 private static java.lang.Integer const__71;
 private static clojure.lang.IPersistentList const__72;
 private static clojure.lang.Keyword const__73;
 private static clojure.lang.IPersistentMap const__74;
 private static clojure.lang.Var const__75;
 private static java.lang.Integer const__76;
 private static clojure.lang.IPersistentList const__77;
 private static clojure.lang.IPersistentMap const__78;
 private static clojure.lang.Var const__79;
 private static java.lang.Integer const__80;
 private static clojure.lang.IPersistentList const__81;
 private static clojure.lang.IPersistentMap const__82;
 private static clojure.lang.Var const__83;
 private static java.lang.Integer const__84;
 private static clojure.lang.IPersistentList const__85;
 private static clojure.lang.IPersistentMap const__86;
 private static clojure.lang.Var const__87;
 private static java.lang.Integer const__88;
 private static clojure.lang.IPersistentList const__89;
 private static clojure.lang.IPersistentMap const__90;
 private static clojure.lang.Var const__91;
 private static java.lang.Integer const__92;
 private static clojure.lang.IPersistentList const__93;
 private static clojure.lang.IPersistentMap const__94;
 private static clojure.lang.Var const__95;
 private static java.lang.Integer const__96;
 private static clojure.lang.IPersistentList const__97;
 private static clojure.lang.IPersistentMap const__98;
 private static clojure.lang.Var const__99;
 private static java.lang.Integer const__100;
 private static clojure.lang.IPersistentList const__101;
 private static clojure.lang.IPersistentMap const__102;
 private static clojure.lang.Var const__103;
 private static java.lang.Integer const__104;
 private static clojure.lang.IPersistentList const__105;
 private static clojure.lang.IPersistentMap const__106;
 private static clojure.lang.Var const__107;
 private static java.lang.Integer const__108;
 private static clojure.lang.IPersistentList const__109;
 private static clojure.lang.IPersistentMap const__110;
 private static clojure.lang.Var const__111;
 private static java.lang.Integer const__112;
 private static clojure.lang.IPersistentList const__113;
 private static clojure.lang.IPersistentMap const__114;
 private static clojure.lang.Var const__115;
 private static java.lang.Integer const__116;
 private static clojure.lang.IPersistentList const__117;
 private static clojure.lang.IPersistentMap const__118;
 private static java.lang.Integer const__119;
 private static clojure.lang.IPersistentList const__120;
 private static clojure.lang.IPersistentMap const__121;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "clojure.main")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "author"), "Stephen C. Gilardi and Rich Hickey", Keyword.intern(null, "doc"), "Top-level main function for Clojure REPL and scripts."));
  const__2 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__3 = (clojure.lang.Var)RT.var("clojure.main", "main");
  const__4 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__5 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__6 = (java.lang.Integer)1;
  const__7 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__8 = (java.lang.Integer)20;
  const__9 = (clojure.lang.Keyword)Keyword.intern(null, "declared");
  const__10 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "declared"), Boolean.TRUE, Keyword.intern(null, "line"), 20, Keyword.intern(null, "file"), "clojure/main.clj");
  const__11 = (clojure.lang.Var)RT.var("clojure.main", "demunge");
  const__12 = (java.lang.Integer)30;
  const__13 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__14 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "fn-name"))));
  const__15 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__16 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__17 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "fn-name")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.3", Keyword.intern(null, "doc"), "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", Keyword.intern(null, "line"), 30, Keyword.intern(null, "file"), "clojure/main.clj");
  const__18 = (clojure.lang.Var)RT.var("clojure.main", "root-cause");
  const__19 = (java.lang.Integer)37;
  const__20 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "t")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Throwable"))))));
  const__21 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "t")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Throwable")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.3", Keyword.intern(null, "doc"), "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", Keyword.intern(null, "line"), 37, Keyword.intern(null, "file"), "clojure/main.clj");
  const__22 = (clojure.lang.Var)RT.var("clojure.main", "stack-element-str");
  const__23 = (java.lang.Integer)50;
  const__24 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "el")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "StackTraceElement"))))));
  const__25 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "el")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "StackTraceElement")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.3", Keyword.intern(null, "doc"), "Returns a (possibly unmunged) string representation of a StackTraceElement", Keyword.intern(null, "line"), 50, Keyword.intern(null, "file"), "clojure/main.clj");
  const__26 = (clojure.lang.Var)RT.var("clojure.main", "with-bindings");
  const__27 = (java.lang.Integer)64;
  const__28 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__29 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Executes body in the context of thread-local bindings for several vars\n  that often need to be set!: *ns* *warn-on-reflection* *math-context*\n  *print-meta* *print-length* *print-level* *compile-path*\n  *command-line-args* *1 *2 *3 *e", Keyword.intern(null, "line"), 64, Keyword.intern(null, "file"), "clojure/main.clj");
  const__30 = (clojure.lang.Var)RT.var("clojure.main", "repl-prompt");
  const__31 = (java.lang.Integer)88;
  const__32 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector()));
  const__33 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector())), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Default :prompt hook for repl", Keyword.intern(null, "line"), 88, Keyword.intern(null, "file"), "clojure/main.clj");
  const__34 = (clojure.lang.Var)RT.var("clojure.main", "skip-if-eol");
  const__35 = (java.lang.Integer)93;
  const__36 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s"))));
  const__37 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", Keyword.intern(null, "line"), 93, Keyword.intern(null, "file"), "clojure/main.clj");
  const__38 = (clojure.lang.Var)RT.var("clojure.main", "skip-whitespace");
  const__39 = (java.lang.Integer)107;
  const__40 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s"))));
  const__41 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", Keyword.intern(null, "line"), 107, Keyword.intern(null, "file"), "clojure/main.clj");
  const__42 = (clojure.lang.Var)RT.var("clojure.main", "repl-read");
  const__43 = (java.lang.Integer)125;
  const__44 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "request-prompt"), Symbol.intern(null, "request-exit"))));
  const__45 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "request-prompt"), Symbol.intern(null, "request-exit")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", Keyword.intern(null, "line"), 125, Keyword.intern(null, "file"), "clojure/main.clj");
  const__46 = (clojure.lang.Var)RT.var("clojure.main", "repl-exception");
  const__47 = (java.lang.Integer)143;
  const__48 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "throwable"))));
  const__49 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "throwable")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Returns the root cause of throwables", Keyword.intern(null, "line"), 143, Keyword.intern(null, "file"), "clojure/main.clj");
  const__50 = (clojure.lang.Var)RT.var("clojure.main", "repl-caught");
  const__51 = (java.lang.Integer)148;
  const__52 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "e"))));
  const__53 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "e")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Default :caught hook for repl", Keyword.intern(null, "line"), 148, Keyword.intern(null, "file"), "clojure/main.clj");
  const__54 = (clojure.lang.Var)RT.var("clojure.main", "repl-requires");
  const__55 = (java.lang.Integer)160;
  const__56 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "A sequence of lib specs that are applied to `require`\nby default when a new command-line REPL is started.", Keyword.intern(null, "line"), 160, Keyword.intern(null, "file"), "clojure/main.clj");
  const__57 = (clojure.lang.PersistentVector)RT.vector(RT.vector(Symbol.intern(null, "clojure.repl"), Keyword.intern(null, "refer"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "source"), Symbol.intern(null, "apropos"), Symbol.intern(null, "dir"), Symbol.intern(null, "pst"), Symbol.intern(null, "doc"), Symbol.intern(null, "find-doc")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 162, Keyword.intern(null, "column"), 26))), RT.vector(Symbol.intern(null, "clojure.java.javadoc"), Keyword.intern(null, "refer"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "javadoc")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 163, Keyword.intern(null, "column"), 34))), RT.vector(Symbol.intern(null, "clojure.pprint"), Keyword.intern(null, "refer"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(Symbol.intern(null, "pp"), Symbol.intern(null, "pprint")))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 164, Keyword.intern(null, "column"), 28))));
  const__58 = (clojure.lang.Var)RT.var("clojure.main", "with-read-known");
  const__59 = (java.lang.Integer)166;
  const__60 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "body"))));
  const__61 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "body")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Evaluates body with *read-eval* set to a \"known\" value,\n   i.e. substituting true for :unknown if necessary.", Keyword.intern(null, "line"), 166, Keyword.intern(null, "file"), "clojure/main.clj");
  const__62 = (clojure.lang.Var)RT.var("clojure.main", "repl");
  const__63 = (java.lang.Integer)173;
  const__64 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "options"))));
  const__65 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "options")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught", Keyword.intern(null, "line"), 173, Keyword.intern(null, "file"), "clojure/main.clj");
  const__66 = (clojure.lang.Var)RT.var("clojure.main", "load-script");
  const__67 = (java.lang.Integer)267;
  const__68 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "path")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String"))))));
  const__69 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "path")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Loads Clojure source from a file or resource given its path. Paths\n  beginning with @ or @/ are considered relative to classpath.", Keyword.intern(null, "line"), 267, Keyword.intern(null, "file"), "clojure/main.clj");
  const__70 = (clojure.lang.Var)RT.var("clojure.main", "init-opt");
  const__71 = (java.lang.Integer)276;
  const__72 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "path"))));
  const__73 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__74 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "path")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Load a script", Keyword.intern(null, "line"), 276, Keyword.intern(null, "file"), "clojure/main.clj");
  const__75 = (clojure.lang.Var)RT.var("clojure.main", "eval-opt");
  const__76 = (java.lang.Integer)281;
  const__77 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "str"))));
  const__78 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "str")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Evals expressions in str, prints each non-nil result using prn", Keyword.intern(null, "line"), 281, Keyword.intern(null, "file"), "clojure/main.clj");
  const__79 = (clojure.lang.Var)RT.var("clojure.main", "init-dispatch");
  const__80 = (java.lang.Integer)293;
  const__81 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opt"))));
  const__82 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opt")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Returns the handler associated with an init opt", Keyword.intern(null, "line"), 293, Keyword.intern(null, "file"), "clojure/main.clj");
  const__83 = (clojure.lang.Var)RT.var("clojure.main", "initialize");
  const__84 = (java.lang.Integer)301;
  const__85 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args"), Symbol.intern(null, "inits"))));
  const__86 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args"), Symbol.intern(null, "inits")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Common initialize routine for repl, script, and null opts", Keyword.intern(null, "line"), 301, Keyword.intern(null, "file"), "clojure/main.clj");
  const__87 = (clojure.lang.Var)RT.var("clojure.main", "main-opt");
  const__88 = (java.lang.Integer)309;
  const__89 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "_"), Symbol.intern(null, "main-ns"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits"))));
  const__90 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "_"), Symbol.intern(null, "main-ns"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Call the -main function from a namespace with string arguments from\n  the command line.", Keyword.intern(null, "line"), 309, Keyword.intern(null, "file"), "clojure/main.clj");
  const__91 = (clojure.lang.Var)RT.var("clojure.main", "repl-opt");
  const__92 = (java.lang.Integer)317;
  const__93 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "_"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits"))));
  const__94 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "_"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Start a repl with args and inits. Print greeting if no eval options were\n  present", Keyword.intern(null, "line"), 317, Keyword.intern(null, "file"), "clojure/main.clj");
  const__95 = (clojure.lang.Var)RT.var("clojure.main", "script-opt");
  const__96 = (java.lang.Integer)329;
  const__97 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "path"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits"))));
  const__98 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "path"), Symbol.intern(null, "&"), Symbol.intern(null, "args")), Symbol.intern(null, "inits")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Run a script from a file, resource, or standard in with args and inits", Keyword.intern(null, "line"), 329, Keyword.intern(null, "file"), "clojure/main.clj");
  const__99 = (clojure.lang.Var)RT.var("clojure.main", "null-opt");
 }
 static void __init1() {
  const__100 = (java.lang.Integer)338;
  const__101 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args"), Symbol.intern(null, "inits"))));
  const__102 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args"), Symbol.intern(null, "inits")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "No repl or script opt present, just bind args and run inits", Keyword.intern(null, "line"), 338, Keyword.intern(null, "file"), "clojure/main.clj");
  const__103 = (clojure.lang.Var)RT.var("clojure.main", "help-opt");
  const__104 = (java.lang.Integer)344;
  const__105 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "_"), Symbol.intern(null, "_"))));
  const__106 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "_"), Symbol.intern(null, "_")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Print help text for main", Keyword.intern(null, "line"), 344, Keyword.intern(null, "file"), "clojure/main.clj");
  const__107 = (clojure.lang.Var)RT.var("clojure.main", "main-dispatch");
  const__108 = (java.lang.Integer)349;
  const__109 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opt"))));
  const__110 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opt")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Returns the handler associated with a main option", Keyword.intern(null, "line"), 349, Keyword.intern(null, "file"), "clojure/main.clj");
  const__111 = (clojure.lang.Var)RT.var("clojure.main", "legacy-repl");
  const__112 = (java.lang.Integer)363;
  const__113 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args"))));
  const__114 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Called by the clojure.lang.Repl.main stub to run a repl with args\n  specified the old way", Keyword.intern(null, "line"), 363, Keyword.intern(null, "file"), "clojure/main.clj");
  const__115 = (clojure.lang.Var)RT.var("clojure.main", "legacy-script");
  const__116 = (java.lang.Integer)373;
  const__117 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args"))));
  const__118 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "args")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Called by the clojure.lang.Script.main stub to run a script with args\n  specified the old way", Keyword.intern(null, "line"), 373, Keyword.intern(null, "file"), "clojure/main.clj");
  const__119 = (java.lang.Integer)383;
  const__120 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "args"))));
  const__121 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "args")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "doc"), "Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]\n\n  With no options or args, runs an interactive Read-Eval-Print Loop\n\n  init options:\n    -i, --init path     Load a file or resource\n    -e, --eval string   Evaluate expressions in string; print non-nil values\n\n  main options:\n    -m, --main ns-name  Call the -main function from a namespace with args\n    -r, --repl          Run a repl\n    path                Run a script from from a file or resource\n    -                   Run a script from standard input\n    -h, -?, --help      Print this help message and exit\n\n  operation:\n\n    - Establishes thread-local bindings for commonly set!-able vars\n    - Enters the user namespace\n    - Binds *command-line-args* to a seq of strings containing command line\n      args that appear after any main option\n    - Runs all init options in order\n    - Calls a -main function or runs a repl or script if requested\n\n  The init options may be repeated and mixed freely, but must appear before\n  any main option. The appearance of any eval option before running a repl\n  suppresses the usual repl greeting message: \"Clojure ~(clojure-version)\".\n\n  Paths may be absolute or relative in the filesystem or relative to\n  classpath. Classpath-relative paths have prefix of @ or @/", Keyword.intern(null, "line"), 383, Keyword.intern(null, "file"), "clojure/main.clj");
 }
 static {
  __init0();
  __init1();
  clojure.lang.Compiler.pushNSandLoader(clojure.main__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
