package clojure;

import clojure.lang.*;

public class string__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  ((IFn)new clojure.string_loading__4931__auto__()).invoke();
  if (((clojure.lang.Symbol)const__1).equals(((java.lang.Object)const__2))) {
  } else {
   clojure.lang.LockingTransaction.runInTransaction((java.util.concurrent.Callable)((java.util.concurrent.Callable)new clojure.string_fn__8760()));
  }
  const__3.setMeta((IPersistentMap)const__15);
  const__3.bindRoot(new clojure.string_reverse());
  const__16.setMeta((IPersistentMap)const__19);
  const__16.bindRoot(new clojure.string_re_quote_replacement());
  const__20.setMeta((IPersistentMap)const__24);
  const__20.bindRoot(new clojure.string_replace_by());
  const__25.setMeta((IPersistentMap)const__28);
  const__25.bindRoot(new clojure.string_replace());
  const__29.setMeta((IPersistentMap)const__32);
  const__29.bindRoot(new clojure.string_replace_first_by());
  const__33.setMeta((IPersistentMap)const__36);
  const__33.bindRoot(new clojure.string_replace_first_char());
  const__37.setMeta((IPersistentMap)const__40);
  const__37.bindRoot(new clojure.string_replace_first_str());
  const__41.setMeta((IPersistentMap)const__44);
  const__41.bindRoot(new clojure.string_replace_first());
  const__45.setMeta((IPersistentMap)const__48);
  const__45.bindRoot(new clojure.string_join());
  const__49.setMeta((IPersistentMap)const__52);
  const__49.bindRoot(new clojure.string_capitalize());
  const__53.setMeta((IPersistentMap)const__56);
  const__53.bindRoot(new clojure.string_upper_case());
  const__57.setMeta((IPersistentMap)const__60);
  const__57.bindRoot(new clojure.string_lower_case());
  const__61.setMeta((IPersistentMap)const__64);
  const__61.bindRoot(new clojure.string_split());
  const__65.setMeta((IPersistentMap)const__68);
  const__65.bindRoot(new clojure.string_split_lines());
  const__69.setMeta((IPersistentMap)const__72);
  const__69.bindRoot(new clojure.string_trim());
  const__73.setMeta((IPersistentMap)const__76);
  const__73.bindRoot(new clojure.string_triml());
  const__77.setMeta((IPersistentMap)const__80);
  const__77.bindRoot(new clojure.string_trimr());
  const__81.setMeta((IPersistentMap)const__84);
  const__81.bindRoot(new clojure.string_trim_newline());
  const__85.setMeta((IPersistentMap)const__88);
  const__85.bindRoot(new clojure.string_blank_QMARK_());
  const__89.setMeta((IPersistentMap)const__92);
  const__89.bindRoot(new clojure.string_escape());
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Symbol const__2;
 private static clojure.lang.Var const__3;
 private static clojure.lang.Keyword const__4;
 private static clojure.lang.Keyword const__5;
 private static java.lang.Integer const__6;
 private static clojure.lang.Keyword const__7;
 private static java.lang.Integer const__8;
 private static clojure.lang.Keyword const__9;
 private static clojure.lang.IPersistentList const__10;
 private static clojure.lang.Keyword const__11;
 private static clojure.lang.Keyword const__12;
 private static clojure.lang.Keyword const__13;
 private static java.lang.Class const__14;
 private static clojure.lang.IPersistentMap const__15;
 private static clojure.lang.Var const__16;
 private static java.lang.Integer const__17;
 private static clojure.lang.IPersistentList const__18;
 private static clojure.lang.IPersistentMap const__19;
 private static clojure.lang.Var const__20;
 private static java.lang.Integer const__21;
 private static clojure.lang.IPersistentList const__22;
 private static clojure.lang.Keyword const__23;
 private static clojure.lang.IPersistentMap const__24;
 private static clojure.lang.Var const__25;
 private static java.lang.Integer const__26;
 private static clojure.lang.IPersistentList const__27;
 private static clojure.lang.IPersistentMap const__28;
 private static clojure.lang.Var const__29;
 private static java.lang.Integer const__30;
 private static clojure.lang.IPersistentList const__31;
 private static clojure.lang.IPersistentMap const__32;
 private static clojure.lang.Var const__33;
 private static java.lang.Integer const__34;
 private static clojure.lang.IPersistentList const__35;
 private static clojure.lang.IPersistentMap const__36;
 private static clojure.lang.Var const__37;
 private static java.lang.Integer const__38;
 private static clojure.lang.IPersistentList const__39;
 private static clojure.lang.IPersistentMap const__40;
 private static clojure.lang.Var const__41;
 private static java.lang.Integer const__42;
 private static clojure.lang.IPersistentList const__43;
 private static clojure.lang.IPersistentMap const__44;
 private static clojure.lang.Var const__45;
 private static java.lang.Integer const__46;
 private static clojure.lang.IPersistentList const__47;
 private static clojure.lang.IPersistentMap const__48;
 private static clojure.lang.Var const__49;
 private static java.lang.Integer const__50;
 private static clojure.lang.IPersistentList const__51;
 private static clojure.lang.IPersistentMap const__52;
 private static clojure.lang.Var const__53;
 private static java.lang.Integer const__54;
 private static clojure.lang.IPersistentList const__55;
 private static clojure.lang.IPersistentMap const__56;
 private static clojure.lang.Var const__57;
 private static java.lang.Integer const__58;
 private static clojure.lang.IPersistentList const__59;
 private static clojure.lang.IPersistentMap const__60;
 private static clojure.lang.Var const__61;
 private static java.lang.Integer const__62;
 private static clojure.lang.IPersistentList const__63;
 private static clojure.lang.IPersistentMap const__64;
 private static clojure.lang.Var const__65;
 private static java.lang.Integer const__66;
 private static clojure.lang.IPersistentList const__67;
 private static clojure.lang.IPersistentMap const__68;
 private static clojure.lang.Var const__69;
 private static java.lang.Integer const__70;
 private static clojure.lang.IPersistentList const__71;
 private static clojure.lang.IPersistentMap const__72;
 private static clojure.lang.Var const__73;
 private static java.lang.Integer const__74;
 private static clojure.lang.IPersistentList const__75;
 private static clojure.lang.IPersistentMap const__76;
 private static clojure.lang.Var const__77;
 private static java.lang.Integer const__78;
 private static clojure.lang.IPersistentList const__79;
 private static clojure.lang.IPersistentMap const__80;
 private static clojure.lang.Var const__81;
 private static java.lang.Integer const__82;
 private static clojure.lang.IPersistentList const__83;
 private static clojure.lang.IPersistentMap const__84;
 private static clojure.lang.Var const__85;
 private static java.lang.Integer const__86;
 private static clojure.lang.IPersistentList const__87;
 private static clojure.lang.IPersistentMap const__88;
 private static clojure.lang.Var const__89;
 private static java.lang.Integer const__90;
 private static clojure.lang.IPersistentList const__91;
 private static clojure.lang.IPersistentMap const__92;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)((clojure.lang.IObj)Symbol.intern(null, "clojure.string")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "author"), "Stuart Sierra, Stuart Halloway, David Liebke", Keyword.intern(null, "doc"), "Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility."));
  const__2 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__3 = (clojure.lang.Var)RT.var("clojure.string", "reverse");
  const__4 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__5 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__6 = (java.lang.Integer)1;
  const__7 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__8 = (java.lang.Integer)46;
  const__9 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__10 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__11 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__12 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__13 = (clojure.lang.Keyword)Keyword.intern(null, "tag");
  const__14 = (java.lang.Class)java.lang.String.class;
  const__15 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Returns s with its characters reversed.", Keyword.intern(null, "line"), 46, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__16 = (clojure.lang.Var)RT.var("clojure.string", "re-quote-replacement");
  const__17 = (java.lang.Integer)52;
  const__18 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "replacement")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__19 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "replacement")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.5", Keyword.intern(null, "doc"), "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.", Keyword.intern(null, "line"), 52, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__20 = (clojure.lang.Var)RT.var("clojure.string", "replace-by");
  const__21 = (java.lang.Integer)60;
  const__22 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "re"), Symbol.intern(null, "f"))));
  const__23 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__24 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "re"), Symbol.intern(null, "f")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 60, Keyword.intern(null, "file"), "clojure/string.clj");
  const__25 = (clojure.lang.Var)RT.var("clojure.string", "replace");
  const__26 = (java.lang.Integer)73;
  const__27 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "match"), Symbol.intern(null, "replacement"))));
  const__28 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "match"), Symbol.intern(null, "replacement")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"", Keyword.intern(null, "line"), 73, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__29 = (clojure.lang.Var)RT.var("clojure.string", "replace-first-by");
  const__30 = (java.lang.Integer)109;
  const__31 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Pattern"))), Symbol.intern(null, "f"))));
  const__32 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Pattern"))), Symbol.intern(null, "f")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 109, Keyword.intern(null, "file"), "clojure/string.clj");
  const__33 = (clojure.lang.Var)RT.var("clojure.string", "replace-first-char");
  const__34 = (java.lang.Integer)120;
  const__35 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "match")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Character"))), Symbol.intern(null, "replace"))));
  const__36 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "match")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Character"))), Symbol.intern(null, "replace")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 120, Keyword.intern(null, "file"), "clojure/string.clj");
  const__37 = (clojure.lang.Var)RT.var("clojure.string", "replace-first-str");
  const__38 = (java.lang.Integer)128;
  const__39 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "match")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String"))), ((clojure.lang.IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String"))))));
  const__40 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "match")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String"))), ((clojure.lang.IObj)Symbol.intern(null, "replace")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "String")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 128, Keyword.intern(null, "file"), "clojure/string.clj");
  const__41 = (clojure.lang.Var)RT.var("clojure.string", "replace-first");
  const__42 = (java.lang.Integer)136;
  const__43 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "match"), Symbol.intern(null, "replacement"))));
  const__44 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "match"), Symbol.intern(null, "replacement")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"", Keyword.intern(null, "line"), 136, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__45 = (clojure.lang.Var)RT.var("clojure.string", "join");
  const__46 = (java.lang.Integer)178;
  const__47 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "separator"), Symbol.intern(null, "coll"))));
  const__48 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "coll")), RT.vector(Symbol.intern(null, "separator"), Symbol.intern(null, "coll")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.", Keyword.intern(null, "line"), 178, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__49 = (clojure.lang.Var)RT.var("clojure.string", "capitalize");
  const__50 = (java.lang.Integer)194;
  const__51 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__52 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Converts first character of the string to upper-case, all other\n  characters to lower-case.", Keyword.intern(null, "line"), 194, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__53 = (clojure.lang.Var)RT.var("clojure.string", "upper-case");
  const__54 = (java.lang.Integer)205;
  const__55 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__56 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Converts string to all upper-case.", Keyword.intern(null, "line"), 205, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__57 = (clojure.lang.Var)RT.var("clojure.string", "lower-case");
  const__58 = (java.lang.Integer)211;
  const__59 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__60 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Converts string to all lower-case.", Keyword.intern(null, "line"), 211, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__61 = (clojure.lang.Var)RT.var("clojure.string", "split");
  const__62 = (java.lang.Integer)217;
  const__63 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Pattern")))), RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Pattern"))), Symbol.intern(null, "limit"))));
  const__64 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Pattern")))), RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), ((clojure.lang.IObj)Symbol.intern(null, "re")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Pattern"))), Symbol.intern(null, "limit")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", Keyword.intern(null, "line"), 217, Keyword.intern(null, "file"), "clojure/string.clj");
  const__65 = (clojure.lang.Var)RT.var("clojure.string", "split-lines");
  const__66 = (java.lang.Integer)226;
  const__67 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__68 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Splits s on \\n or \\r\\n.", Keyword.intern(null, "line"), 226, Keyword.intern(null, "file"), "clojure/string.clj");
  const__69 = (clojure.lang.Var)RT.var("clojure.string", "trim");
  const__70 = (java.lang.Integer)232;
  const__71 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__72 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Removes whitespace from both ends of string.", Keyword.intern(null, "line"), 232, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__73 = (clojure.lang.Var)RT.var("clojure.string", "triml");
  const__74 = (java.lang.Integer)238;
  const__75 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__76 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Removes whitespace from the left side of string.", Keyword.intern(null, "line"), 238, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__77 = (clojure.lang.Var)RT.var("clojure.string", "trimr");
  const__78 = (java.lang.Integer)249;
  const__79 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__80 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Removes whitespace from the right side of string.", Keyword.intern(null, "line"), 249, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__81 = (clojure.lang.Var)RT.var("clojure.string", "trim-newline");
  const__82 = (java.lang.Integer)260;
  const__83 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__84 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", Keyword.intern(null, "line"), 260, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
  const__85 = (clojure.lang.Var)RT.var("clojure.string", "blank?");
  const__86 = (java.lang.Integer)273;
  const__87 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))))));
  const__88 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "True if s is nil, empty, or contains only whitespace.", Keyword.intern(null, "line"), 273, Keyword.intern(null, "file"), "clojure/string.clj");
  const__89 = (clojure.lang.Var)RT.var("clojure.string", "escape");
  const__90 = (java.lang.Integer)286;
  const__91 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "cmap"))));
  const__92 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "s")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "CharSequence"))), Symbol.intern(null, "cmap")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", Keyword.intern(null, "line"), 286, Keyword.intern(null, "file"), "clojure/string.clj", Keyword.intern(null, "tag"), java.lang.String.class);
 }
 static {
  __init0();
  clojure.lang.Compiler.pushNSandLoader(clojure.string__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
