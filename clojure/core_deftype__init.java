package clojure;

import clojure.lang.*;

public class core_deftype__init {
 public static void load() throws Exception {
  ((IFn)const__0.getRawRoot()).invoke(const__1);
  const__2.setMeta((IPersistentMap)const__12);
  const__2.bindRoot(new clojure.core_namespace_munge());
  const__13.setMeta((IPersistentMap)const__16);
  const__13.bindRoot(new clojure.core_definterface());
  ((clojure.lang.Var)const__13).setMacro();
  const__17.setMeta((IPersistentMap)const__21);
  const__17.bindRoot(new clojure.core_parse_opts());
  const__22.setMeta((IPersistentMap)const__25);
  const__22.bindRoot(new clojure.core_parse_impls());
  const__26.setMeta((IPersistentMap)const__29);
  const__26.bindRoot(new clojure.core_parse_opts_PLUS_specs());
  const__30.setMeta((IPersistentMap)const__33);
  const__30.bindRoot(new clojure.core_reify());
  ((clojure.lang.Var)const__30).setMacro();
  const__34.setMeta((IPersistentMap)const__37);
  const__34.bindRoot(new clojure.core_hash_combine());
  const__38.setMeta((IPersistentMap)const__41);
  const__38.bindRoot(new clojure.core_munge());
  const__42.setMeta((IPersistentMap)const__45);
  const__42.bindRoot(new clojure.core_imap_cons());
  const__46.setMeta((IPersistentMap)const__49);
  const__46.bindRoot(new clojure.core_emit_defrecord());
  const__50.setMeta((IPersistentMap)const__53);
  const__50.bindRoot(new clojure.core_build_positional_factory());
  const__54.setMeta((IPersistentMap)const__57);
  const__54.bindRoot(new clojure.core_validate_fields());
  const__58.setMeta((IPersistentMap)const__61);
  const__58.bindRoot(new clojure.core_defrecord());
  ((clojure.lang.Var)const__58).setMacro();
  const__62.setMeta((IPersistentMap)const__65);
  const__62.bindRoot(new clojure.core_emit_deftype_STAR_());
  const__66.setMeta((IPersistentMap)const__69);
  const__66.bindRoot(new clojure.core_deftype());
  ((clojure.lang.Var)const__66).setMacro();
  const__70.setMeta((IPersistentMap)const__73);
  const__70.bindRoot(new clojure.core_expand_method_impl_cache());
  const__74.setMeta((IPersistentMap)const__77);
  const__74.bindRoot(new clojure.core_super_chain());
  const__78.setMeta((IPersistentMap)const__81);
  const__78.bindRoot(new clojure.core_pref());
  const__82.setMeta((IPersistentMap)const__85);
  const__82.bindRoot(new clojure.core_find_protocol_impl());
  const__86.setMeta((IPersistentMap)const__89);
  const__86.bindRoot(new clojure.core_find_protocol_method());
  const__90.setMeta((IPersistentMap)const__93);
  const__90.bindRoot(new clojure.core_protocol_QMARK_());
  const__94.setMeta((IPersistentMap)const__97);
  const__94.bindRoot(new clojure.core_implements_QMARK_());
  const__98.setMeta((IPersistentMap)const__101);
  const__98.bindRoot(new clojure.core_extends_QMARK_());
  const__102.setMeta((IPersistentMap)const__105);
  const__102.bindRoot(new clojure.core_extenders());
  const__106.setMeta((IPersistentMap)const__109);
  const__106.bindRoot(new clojure.core_satisfies_QMARK_());
  const__110.setMeta((IPersistentMap)const__113);
  const__110.bindRoot(new clojure.core__cache_protocol_fn());
  const__114.setMeta((IPersistentMap)const__117);
  const__114.bindRoot(new clojure.core_emit_method_builder());
  const__118.setMeta((IPersistentMap)const__121);
  const__118.bindRoot(new clojure.core__reset_methods());
  const__122.setMeta((IPersistentMap)const__125);
  const__122.bindRoot(new clojure.core_assert_same_protocol());
  const__126.setMeta((IPersistentMap)const__129);
  const__126.bindRoot(new clojure.core_emit_protocol());
  const__130.setMeta((IPersistentMap)const__133);
  const__130.bindRoot(new clojure.core_defprotocol());
  ((clojure.lang.Var)const__130).setMacro();
  const__134.setMeta((IPersistentMap)const__137);
  const__134.bindRoot(new clojure.core_emit_impl());
  const__138.setMeta((IPersistentMap)const__141);
  const__138.bindRoot(new clojure.core_emit_hinted_impl());
  const__142.setMeta((IPersistentMap)const__145);
  const__142.bindRoot(new clojure.core_emit_extend_type());
  const__146.setMeta((IPersistentMap)const__149);
  const__146.bindRoot(new clojure.core_extend_type());
  ((clojure.lang.Var)const__146).setMacro();
  const__150.setMeta((IPersistentMap)const__153);
  const__150.bindRoot(new clojure.core_emit_extend_protocol());
  const__154.setMeta((IPersistentMap)const__157);
  const__154.bindRoot(new clojure.core_extend_protocol());
  ((clojure.lang.Var)const__154).setMacro();
  const__158.setMeta((IPersistentMap)const__161);
  const__158.bindRoot(new clojure.core_extend());
 }
 private static clojure.lang.Var const__0;
 private static clojure.lang.Symbol const__1;
 private static clojure.lang.Var const__2;
 private static clojure.lang.Keyword const__3;
 private static clojure.lang.Keyword const__4;
 private static java.lang.Integer const__5;
 private static clojure.lang.Keyword const__6;
 private static java.lang.Integer const__7;
 private static clojure.lang.Keyword const__8;
 private static clojure.lang.IPersistentList const__9;
 private static clojure.lang.Keyword const__10;
 private static clojure.lang.Keyword const__11;
 private static clojure.lang.IPersistentMap const__12;
 private static clojure.lang.Var const__13;
 private static java.lang.Integer const__14;
 private static clojure.lang.IPersistentList const__15;
 private static clojure.lang.IPersistentMap const__16;
 private static clojure.lang.Var const__17;
 private static java.lang.Integer const__18;
 private static clojure.lang.IPersistentList const__19;
 private static clojure.lang.Keyword const__20;
 private static clojure.lang.IPersistentMap const__21;
 private static clojure.lang.Var const__22;
 private static java.lang.Integer const__23;
 private static clojure.lang.IPersistentList const__24;
 private static clojure.lang.IPersistentMap const__25;
 private static clojure.lang.Var const__26;
 private static java.lang.Integer const__27;
 private static clojure.lang.IPersistentList const__28;
 private static clojure.lang.IPersistentMap const__29;
 private static clojure.lang.Var const__30;
 private static java.lang.Integer const__31;
 private static clojure.lang.IPersistentList const__32;
 private static clojure.lang.IPersistentMap const__33;
 private static clojure.lang.Var const__34;
 private static java.lang.Integer const__35;
 private static clojure.lang.IPersistentList const__36;
 private static clojure.lang.IPersistentMap const__37;
 private static clojure.lang.Var const__38;
 private static java.lang.Integer const__39;
 private static clojure.lang.IPersistentList const__40;
 private static clojure.lang.IPersistentMap const__41;
 private static clojure.lang.Var const__42;
 private static java.lang.Integer const__43;
 private static clojure.lang.IPersistentList const__44;
 private static clojure.lang.IPersistentMap const__45;
 private static clojure.lang.Var const__46;
 private static java.lang.Integer const__47;
 private static clojure.lang.IPersistentList const__48;
 private static clojure.lang.IPersistentMap const__49;
 private static clojure.lang.Var const__50;
 private static java.lang.Integer const__51;
 private static clojure.lang.IPersistentList const__52;
 private static clojure.lang.IPersistentMap const__53;
 private static clojure.lang.Var const__54;
 private static java.lang.Integer const__55;
 private static clojure.lang.IPersistentList const__56;
 private static clojure.lang.IPersistentMap const__57;
 private static clojure.lang.Var const__58;
 private static java.lang.Integer const__59;
 private static clojure.lang.IPersistentList const__60;
 private static clojure.lang.IPersistentMap const__61;
 private static clojure.lang.Var const__62;
 private static java.lang.Integer const__63;
 private static clojure.lang.IPersistentList const__64;
 private static clojure.lang.IPersistentMap const__65;
 private static clojure.lang.Var const__66;
 private static java.lang.Integer const__67;
 private static clojure.lang.IPersistentList const__68;
 private static clojure.lang.IPersistentMap const__69;
 private static clojure.lang.Var const__70;
 private static java.lang.Integer const__71;
 private static clojure.lang.IPersistentList const__72;
 private static clojure.lang.IPersistentMap const__73;
 private static clojure.lang.Var const__74;
 private static java.lang.Integer const__75;
 private static clojure.lang.IPersistentList const__76;
 private static clojure.lang.IPersistentMap const__77;
 private static clojure.lang.Var const__78;
 private static java.lang.Integer const__79;
 private static clojure.lang.IPersistentList const__80;
 private static clojure.lang.IPersistentMap const__81;
 private static clojure.lang.Var const__82;
 private static java.lang.Integer const__83;
 private static clojure.lang.IPersistentList const__84;
 private static clojure.lang.IPersistentMap const__85;
 private static clojure.lang.Var const__86;
 private static java.lang.Integer const__87;
 private static clojure.lang.IPersistentList const__88;
 private static clojure.lang.IPersistentMap const__89;
 private static clojure.lang.Var const__90;
 private static java.lang.Integer const__91;
 private static clojure.lang.IPersistentList const__92;
 private static clojure.lang.IPersistentMap const__93;
 private static clojure.lang.Var const__94;
 private static java.lang.Integer const__95;
 private static clojure.lang.IPersistentList const__96;
 private static clojure.lang.IPersistentMap const__97;
 private static clojure.lang.Var const__98;
 private static java.lang.Integer const__99;
 private static clojure.lang.IPersistentList const__100;
 private static clojure.lang.IPersistentMap const__101;
 private static clojure.lang.Var const__102;
 private static java.lang.Integer const__103;
 private static clojure.lang.IPersistentList const__104;
 private static clojure.lang.IPersistentMap const__105;
 private static clojure.lang.Var const__106;
 private static java.lang.Integer const__107;
 private static clojure.lang.IPersistentList const__108;
 private static clojure.lang.IPersistentMap const__109;
 private static clojure.lang.Var const__110;
 private static java.lang.Integer const__111;
 private static clojure.lang.IPersistentList const__112;
 private static clojure.lang.IPersistentMap const__113;
 private static clojure.lang.Var const__114;
 private static java.lang.Integer const__115;
 private static clojure.lang.IPersistentList const__116;
 private static clojure.lang.IPersistentMap const__117;
 private static clojure.lang.Var const__118;
 private static java.lang.Integer const__119;
 private static clojure.lang.IPersistentList const__120;
 private static clojure.lang.IPersistentMap const__121;
 private static clojure.lang.Var const__122;
 private static java.lang.Integer const__123;
 private static clojure.lang.IPersistentList const__124;
 private static clojure.lang.IPersistentMap const__125;
 private static clojure.lang.Var const__126;
 private static java.lang.Integer const__127;
 private static clojure.lang.IPersistentList const__128;
 private static clojure.lang.IPersistentMap const__129;
 private static clojure.lang.Var const__130;
 private static java.lang.Integer const__131;
 private static clojure.lang.IPersistentList const__132;
 private static clojure.lang.IPersistentMap const__133;
 private static clojure.lang.Var const__134;
 private static java.lang.Integer const__135;
 private static clojure.lang.IPersistentList const__136;
 private static clojure.lang.IPersistentMap const__137;
 private static clojure.lang.Var const__138;
 private static java.lang.Integer const__139;
 private static clojure.lang.IPersistentList const__140;
 private static clojure.lang.IPersistentMap const__141;
 private static clojure.lang.Var const__142;
 private static java.lang.Integer const__143;
 private static clojure.lang.IPersistentList const__144;
 private static clojure.lang.IPersistentMap const__145;
 private static clojure.lang.Var const__146;
 private static java.lang.Integer const__147;
 private static clojure.lang.IPersistentList const__148;
 private static clojure.lang.IPersistentMap const__149;
 private static clojure.lang.Var const__150;
 private static java.lang.Integer const__151;
 private static clojure.lang.IPersistentList const__152;
 private static clojure.lang.IPersistentMap const__153;
 private static clojure.lang.Var const__154;
 private static java.lang.Integer const__155;
 private static clojure.lang.IPersistentList const__156;
 private static clojure.lang.IPersistentMap const__157;
 private static clojure.lang.Var const__158;
 private static java.lang.Integer const__159;
 private static clojure.lang.IPersistentList const__160;
 private static clojure.lang.IPersistentMap const__161;
 static void __init0() {
  const__0 = (clojure.lang.Var)RT.var("clojure.core", "in-ns");
  const__1 = (clojure.lang.Symbol)Symbol.intern(null, "clojure.core");
  const__2 = (clojure.lang.Var)RT.var("clojure.core", "namespace-munge");
  const__3 = (clojure.lang.Keyword)Keyword.intern(null, "file");
  const__4 = (clojure.lang.Keyword)Keyword.intern(null, "column");
  const__5 = (java.lang.Integer)1;
  const__6 = (clojure.lang.Keyword)Keyword.intern(null, "line");
  const__7 = (java.lang.Integer)12;
  const__8 = (clojure.lang.Keyword)Keyword.intern(null, "arglists");
  const__9 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "ns"))));
  const__10 = (clojure.lang.Keyword)Keyword.intern(null, "added");
  const__11 = (clojure.lang.Keyword)Keyword.intern(null, "doc");
  const__12 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "ns")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Convert a Clojure namespace name to a legal Java package name.", Keyword.intern(null, "line"), 12, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__13 = (clojure.lang.Var)RT.var("clojure.core", "definterface");
  const__14 = (java.lang.Integer)19;
  const__15 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "sigs"))));
  const__16 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "sigs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n  (^int method1 [x])\n  (^Bar method2 [^Baz b ^Quux q]))", Keyword.intern(null, "line"), 19, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__17 = (clojure.lang.Var)RT.var("clojure.core", "parse-opts");
  const__18 = (java.lang.Integer)39;
  const__19 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s"))));
  const__20 = (clojure.lang.Keyword)Keyword.intern(null, "private");
  const__21 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 39, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__22 = (clojure.lang.Var)RT.var("clojure.core", "parse-impls");
  const__23 = (java.lang.Integer)45;
  const__24 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "specs"))));
  const__25 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 45, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__26 = (clojure.lang.Var)RT.var("clojure.core", "parse-opts+specs");
  const__27 = (java.lang.Integer)52;
  const__28 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opts+specs"))));
  const__29 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "opts+specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 52, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__30 = (clojure.lang.Var)RT.var("clojure.core", "reify");
  const__31 = (java.lang.Integer)69;
  const__32 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs"))));
  const__33 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "reify is a macro with the following structure:\n\n  (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n  (reify Object\n  (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n  (reify clojure.lang.Seqable\n  (seq [this] (seq f)))))\n  == (\\f \\o \\o))\n\n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", Keyword.intern(null, "line"), 69, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__34 = (clojure.lang.Var)RT.var("clojure.core", "hash-combine");
  const__35 = (java.lang.Integer)125;
  const__36 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x"), Symbol.intern(null, "y"))));
  const__37 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "x"), Symbol.intern(null, "y")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 125, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__38 = (clojure.lang.Var)RT.var("clojure.core", "munge");
  const__39 = (java.lang.Integer)128;
  const__40 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s"))));
  const__41 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "s")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 128, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__42 = (clojure.lang.Var)RT.var("clojure.core", "imap-cons");
  const__43 = (java.lang.Integer)131;
  const__44 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "this")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "IPersistentMap"))), Symbol.intern(null, "o"))));
  const__45 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "this")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "IPersistentMap"))), Symbol.intern(null, "o")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 131, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__46 = (clojure.lang.Var)RT.var("clojure.core", "emit-defrecord");
  const__47 = (java.lang.Integer)147;
  const__48 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "tagname"), Symbol.intern(null, "name"), Symbol.intern(null, "fields"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "methods"))));
  const__49 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "tagname"), Symbol.intern(null, "name"), Symbol.intern(null, "fields"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "methods")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Do not use this directly - use defrecord", Keyword.intern(null, "line"), 147, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__50 = (clojure.lang.Var)RT.var("clojure.core", "build-positional-factory");
  const__51 = (java.lang.Integer)248;
  const__52 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "nom"), Symbol.intern(null, "classname"), Symbol.intern(null, "fields"))));
  const__53 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "nom"), Symbol.intern(null, "classname"), Symbol.intern(null, "fields")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Used to build a positional factory for a given type/record.  Because of the\n  limitation of 20 arguments to Clojure functions, this factory needs to be\n  constructed to deal with more arguments.  It does this by building a straight\n  forward type/record ctor call in the <=20 case, and a call to the same\n  ctor pulling the extra args out of the & overage parameter.  Finally, the\n  arity is constrained to the number of expected fields and an ArityException\n  will be thrown at runtime if the actual arg count does not match.", Keyword.intern(null, "line"), 248, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__54 = (clojure.lang.Var)RT.var("clojure.core", "validate-fields");
  const__55 = (java.lang.Integer)275;
  const__56 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "fields"))));
  const__57 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "fields")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "", Keyword.intern(null, "line"), 275, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__58 = (clojure.lang.Var)RT.var("clojure.core", "defrecord");
  const__59 = (java.lang.Integer)284;
  const__60 = (clojure.lang.IPersistentList)((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "fields")), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs"))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 352, Keyword.intern(null, "column"), 15));
  const__61 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "fields")), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs"))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 352, Keyword.intern(null, "column"), 15)), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Alpha - subject to change\n\n  (defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", Keyword.intern(null, "line"), 284, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__62 = (clojure.lang.Var)RT.var("clojure.core", "emit-deftype*");
  const__63 = (java.lang.Integer)373;
  const__64 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "tagname"), Symbol.intern(null, "name"), Symbol.intern(null, "fields"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "methods"))));
  const__65 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "tagname"), Symbol.intern(null, "name"), Symbol.intern(null, "fields"), Symbol.intern(null, "interfaces"), Symbol.intern(null, "methods")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "doc"), "Do not use this directly - use deftype", Keyword.intern(null, "line"), 373, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__66 = (clojure.lang.Var)RT.var("clojure.core", "deftype");
  const__67 = (java.lang.Integer)382;
  const__68 = (clojure.lang.IPersistentList)((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "fields")), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs"))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 446, Keyword.intern(null, "column"), 15));
  const__69 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), ((clojure.lang.IObj)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), RT.vector(Symbol.intern(null, "&"), Symbol.intern(null, "fields")), Symbol.intern(null, "&"), Symbol.intern(null, "opts+specs"))))).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "line"), 446, Keyword.intern(null, "column"), 15)), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Alpha - subject to change\n\n  (deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directy. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", Keyword.intern(null, "line"), 382, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__70 = (clojure.lang.Var)RT.var("clojure.core", "expand-method-impl-cache");
  const__71 = (java.lang.Integer)465;
  const__72 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "cache")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "clojure.lang.MethodImplCache"))), Symbol.intern(null, "c"), Symbol.intern(null, "f"))));
  const__73 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "cache")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "clojure.lang.MethodImplCache"))), Symbol.intern(null, "c"), Symbol.intern(null, "f")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 465, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__74 = (clojure.lang.Var)RT.var("clojure.core", "super-chain");
  const__75 = (java.lang.Integer)482;
  const__76 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))))));
  const__77 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 482, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__78 = (clojure.lang.Var)RT.var("clojure.core", "pref");
  const__79 = (java.lang.Integer)486;
  const__80 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "a")), RT.vector(((clojure.lang.IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), ((clojure.lang.IObj)Symbol.intern(null, "b")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))))));
  const__81 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(), RT.vector(Symbol.intern(null, "a")), RT.vector(((clojure.lang.IObj)Symbol.intern(null, "a")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), ((clojure.lang.IObj)Symbol.intern(null, "b")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 486, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__82 = (clojure.lang.Var)RT.var("clojure.core", "find-protocol-impl");
  const__83 = (java.lang.Integer)492;
  const__84 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "x"))));
  const__85 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 492, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__86 = (clojure.lang.Var)RT.var("clojure.core", "find-protocol-method");
  const__87 = (java.lang.Integer)503;
  const__88 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "methodk"), Symbol.intern(null, "x"))));
  const__89 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "methodk"), Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 503, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__90 = (clojure.lang.Var)RT.var("clojure.core", "protocol?");
  const__91 = (java.lang.Integer)506;
  const__92 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "maybe-p"))));
  const__93 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "maybe-p")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 506, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__94 = (clojure.lang.Var)RT.var("clojure.core", "implements?");
  const__95 = (java.lang.Integer)510;
  const__96 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "atype"))));
  const__97 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "atype")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 510, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__98 = (clojure.lang.Var)RT.var("clojure.core", "extends?");
  const__99 = (java.lang.Integer)513;
 }
 static void __init1() {
  const__100 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "atype"))));
  const__101 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "atype")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Returns true if atype extends protocol", Keyword.intern(null, "line"), 513, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__102 = (clojure.lang.Var)RT.var("clojure.core", "extenders");
  const__103 = (java.lang.Integer)520;
  const__104 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"))));
  const__105 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Returns a collection of the types explicitly extending protocol", Keyword.intern(null, "line"), 520, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__106 = (clojure.lang.Var)RT.var("clojure.core", "satisfies?");
  const__107 = (java.lang.Integer)526;
  const__108 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "x"))));
  const__109 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"), Symbol.intern(null, "x")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Returns true if x satisfies the protocol", Keyword.intern(null, "line"), 526, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__110 = (clojure.lang.Var)RT.var("clojure.core", "-cache-protocol-fn");
  const__111 = (java.lang.Integer)532;
  const__112 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "pf")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "clojure.lang.AFunction"))), Symbol.intern(null, "x"), ((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), ((clojure.lang.IObj)Symbol.intern(null, "interf")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "clojure.lang.IFn"))))));
  const__113 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(((clojure.lang.IObj)Symbol.intern(null, "pf")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "clojure.lang.AFunction"))), Symbol.intern(null, "x"), ((clojure.lang.IObj)Symbol.intern(null, "c")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "Class"))), ((clojure.lang.IObj)Symbol.intern(null, "interf")).withMeta((IPersistentMap)RT.map(Keyword.intern(null, "tag"), Symbol.intern(null, "clojure.lang.IFn")))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 532, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__114 = (clojure.lang.Var)RT.var("clojure.core", "emit-method-builder");
  const__115 = (java.lang.Integer)544;
  const__116 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "on-interface"), Symbol.intern(null, "method"), Symbol.intern(null, "on-method"), Symbol.intern(null, "arglists"))));
  const__117 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "on-interface"), Symbol.intern(null, "method"), Symbol.intern(null, "on-method"), Symbol.intern(null, "arglists")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 544, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__118 = (clojure.lang.Var)RT.var("clojure.core", "-reset-methods");
  const__119 = (java.lang.Integer)574;
  const__120 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol"))));
  const__121 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "line"), 574, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__122 = (clojure.lang.Var)RT.var("clojure.core", "assert-same-protocol");
  const__123 = (java.lang.Integer)579;
  const__124 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol-var"), Symbol.intern(null, "method-syms"))));
  const__125 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "protocol-var"), Symbol.intern(null, "method-syms")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 579, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__126 = (clojure.lang.Var)RT.var("clojure.core", "emit-protocol");
  const__127 = (java.lang.Integer)590;
  const__128 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "opts+sigs"))));
  const__129 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "opts+sigs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 590, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__130 = (clojure.lang.Var)RT.var("clojure.core", "defprotocol");
  const__131 = (java.lang.Integer)649;
  const__132 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "opts+sigs"))));
  const__133 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "name"), Symbol.intern(null, "&"), Symbol.intern(null, "opts+sigs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n  ;optional doc string\n  \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n  (bar [this a b] \"bar docs\")\n  (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  Java parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types or classes. Implementations of\n  the protocol methods can be provided using extend.\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P\n  (foo [this])\n  (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n  P\n  (foo [this] a)\n  (bar-me [this] b)\n  (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n  (let [x 42]\n  (reify P\n  (foo [this] 17)\n  (bar-me [this] x)\n  (bar-me [this y] x))))\n  => 17", Keyword.intern(null, "line"), 649, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__134 = (clojure.lang.Var)RT.var("clojure.core", "emit-impl");
  const__135 = (java.lang.Integer)703;
  const__136 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "fs")))));
  const__137 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "fs"))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 703, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__138 = (clojure.lang.Var)RT.var("clojure.core", "emit-hinted-impl");
  const__139 = (java.lang.Integer)707;
  const__140 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "c"), RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "fs")))));
  const__141 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "c"), RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "fs"))))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 707, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__142 = (clojure.lang.Var)RT.var("clojure.core", "emit-extend-type");
  const__143 = (java.lang.Integer)719;
  const__144 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "c"), Symbol.intern(null, "specs"))));
  const__145 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "c"), Symbol.intern(null, "specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 719, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__146 = (clojure.lang.Var)RT.var("clojure.core", "extend-type");
  const__147 = (java.lang.Integer)724;
  const__148 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "t"), Symbol.intern(null, "&"), Symbol.intern(null, "specs"))));
  const__149 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "t"), Symbol.intern(null, "&"), Symbol.intern(null, "specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType\n  Countable\n  (cnt [c] ...)\n  Foo\n  (bar [x y] ...)\n  (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n  Countable\n  {:cnt (fn [c] ...)}\n  Foo\n  {:baz (fn ([x] ...) ([x y & zs] ...))\n  :bar (fn [x y] ...)})", Keyword.intern(null, "line"), 724, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__150 = (clojure.lang.Var)RT.var("clojure.core", "emit-extend-protocol");
  const__151 = (java.lang.Integer)749;
  const__152 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "specs"))));
  const__153 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "private"), Boolean.TRUE, Keyword.intern(null, "line"), 749, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__154 = (clojure.lang.Var)RT.var("clojure.core", "extend-protocol");
  const__155 = (java.lang.Integer)756;
  const__156 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "&"), Symbol.intern(null, "specs"))));
  const__157 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "p"), Symbol.intern(null, "&"), Symbol.intern(null, "specs")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n  AType\n  (foo [x] ...)\n  (bar [x y] ...)\n  BType\n  (foo [x] ...)\n  (bar [x y] ...)\n  AClass\n  (foo [x] ...)\n  (bar [x y] ...)\n  nil\n  (foo [x] ...)\n  (bar [x y] ...))\n\n  expands into:\n\n  (do\n  (clojure.core/extend-type AType Protocol\n  (foo [x] ...)\n  (bar [x y] ...))\n  (clojure.core/extend-type BType Protocol\n  (foo [x] ...)\n  (bar [x y] ...))\n  (clojure.core/extend-type AClass Protocol\n  (foo [x] ...)\n  (bar [x y] ...))\n  (clojure.core/extend-type nil Protocol\n  (foo [x] ...)\n  (bar [x y] ...)))", Keyword.intern(null, "line"), 756, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
  const__158 = (clojure.lang.Var)RT.var("clojure.core", "extend");
  const__159 = (java.lang.Integer)796;
  const__160 = (clojure.lang.IPersistentList)PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "atype"), Symbol.intern(null, "&"), Symbol.intern(null, "proto+mmaps"))));
  const__161 = (clojure.lang.IPersistentMap)RT.map(Keyword.intern(null, "arglists"), PersistentList.create(java.util.Arrays.asList(RT.vector(Symbol.intern(null, "atype"), Symbol.intern(null, "&"), Symbol.intern(null, "proto+mmaps")))), Keyword.intern(null, "column"), 1, Keyword.intern(null, "added"), "1.2", Keyword.intern(null, "doc"), "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n  AProtocol\n  {:foo an-existing-fn\n  :bar (fn [a b] ...)\n  :baz (fn ([a]...) ([a b] ...)...)}\n  BProtocol\n  {...}\n  ...)\n\n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument.\n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", Keyword.intern(null, "line"), 796, Keyword.intern(null, "file"), "clojure/core_deftype.clj");
 }
 static {
  __init0();
  __init1();
  clojure.lang.Compiler.pushNSandLoader(clojure.core_deftype__init.class.getClassLoader());
  try {
   load();
  } catch (Exception ___x) {
  throw new RuntimeException(___x);
  } finally {
   Var.popThreadBindings();
  }
 }
}
